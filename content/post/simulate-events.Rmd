---
title: 'Simulating Events & Shade Across Time & Terrain'
author: John
date: '2020-08-16'
draft: false
categories:
  - GL
tags:
  - GL
  - Ray-Tracing
  - Shadows
  - SvelteJS
  - SvelteGL
  - Terrain
  - WebGL
---

<div id="simulation-app" role="main" style="width: 100%;">
&nbsp;
</div>

## Simulating Events & Shade Across Time & Terrain

```{r setup, cache = FALSE, echo = FALSE, include=FALSE}
options(warn = -1)
working_dir <- getwd()
print(working_dir)
if (!require("knitr")) {
    install.packages("knitr")
    library("knitr")
}
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(echo = TRUE)

# Load reticulate package for running python
if (!require("png")) {
    install.packages("png")
}
library(png)

DISPLACE_MULTIPLY <- 0.125
```


```{r images, cache = FALSE, echo = FALSE, results = "asis"}

if (file.exists("data/terrain-colormap.png")) {
    color_input <- "data/terrain-colormap.png"
} else {
    color_input <- file.choose()
}

image_color <- data.frame(png::readPNG(color_input))

#if (file.exists("data/terrain-medium.png")) {
#    medium_input <- "data/terrain-medium.png"
if (file.exists("data/terrain-small.png")) {
    medium_input <- "data/terrain-small.png"
#if (file.exists("data/terrain-tiny.png")) {
#    medium_input <- "data/terrain-tiny.png"
} else {
    medium_input <- file.choose()
}

image_gray <- data.frame(png::readPNG(medium_input))

cat(paste0('<img id="colormap" src="/post/', color_input, '" style="float: right; width:256px; padding: 1%;" />'))
```

Beginning with two texture images describing the same terrain, one color and one grayscale, the first objective is to simulate the perceived time-of-day by altering the color texture with light and shade effects.

Once the vertices, the normals, and the texture coordinates have been built for this new map, I will need indices to tie everything together. The sequence of the indices will trace the vertices into triangular faces:

```{r idx_data, cache = FALSE, echo = FALSE}

mapTerrainCoords <- function (image_map, image_width, image_height) {
    # make a 2.0 x 2.0 plane, starting from at (-1, -1, 0) ... z is up
    heights <- matrix(nrow = image_width, ncol = image_height)
    height_array <- array(dim = c(image_height, image_width))
    vertices <- list()
    normals <- list()
    normal_array <- array(dim = c(image_height, image_width, 3))
    textureCoords <- list()

    # map heights
    for (y in 1:image_height) {
        for (x in 1:image_width) {
            heights[y, x] <- round(image_map[y, x], 6)
        }
    }

    # map vetices, normals, texture
    i <- 0
    for (y in 1:image_height) {
        height_array_x <- c()
        for (x in 1:image_width) {
            i <- i + 1 # increment before to start on 1
            height_array_x <- c(height_array_x , heights[y, x])
            # vertices (x, y, z)
            # png y-coordinate system is reverse of WebGL
            vertices[[i]] <- c(2.0 * round((x / image_width - (1.0 / image_width) - 0.5), 6), 2.0 * round((y / image_height - (1.0 / image_height) - 0.5), 6), heights[(image_width + 1) - y, x] * DISPLACE_MULTIPLY)  # z is up
            # normals
            normals[[i]] <- c(0.0, 0.0, 1.0)
            # texture coordinates (s, t)
            textureCoords[[i]] <- c(round((x / image_width - ((image_width - x) /  (image_width * image_width))), 6), round(1.0 - (y / image_height - ((image_height - y) /  (image_height * image_height))), 6)) # go to flip the y
        }

        # start mapping z normals
        for (x in 1:image_width) {
            normal_array[y, x,] <- c(0.0, 0.0, round(height_array_x[x], 6))
        }

        height_array[y,] <- height_array_x
    }

    total_points <- i

    print(total_points)

    print("heights:")
    print(length(height_array[1,]) * length(height_array[,1]))
    print(length(height_array[1,]))

    print("vertices:")
    print(length(vertices))
    print(length(vertices[[1]]))

    print("textureCoords:")
    print(length(textureCoords))
    print(length(textureCoords[[1]]))

    # Now re-calculate x and y normals based on neighboring heightmap coords
    i <- 0
    for (y in 1:image_height) {
        for (x in 1:image_width) {
            i <- i + 1 # increment before to start on 1
            # png y-coordinate system is reverse of WebGL
            if (x < image_width) {
                za <- normal_array[(image_width + 1) - y, x, 3]
                zb <- normal_array[(image_width + 1) - y, x + 1, 3]
                xa <- (za - zb) # / image_width
                # print(paste0(za, " - ", zb,  " = ", xa))
                # normal_array[y, x,] <- c(round(xa, 6), 0.0, 0.0)
                normal_array[(image_width + 1) - y, x,] <- c(round(xa, 6), normal_array[(image_width + 1) - y, x, 2], normal_array[(image_width + 1) - y, x, 3])
                normals[[i]] <- normal_array[(image_width + 1) - y, x,]
            }
            if (y < image_height) {
                za <- normal_array[(image_width + 1) - y, x, 3]
                zb <- normal_array[(image_width + 1) - (y + 1), x, 3]
                ya <- (za - zb) # / image_height
                # print(paste0(za, " - ", zb,  " = ", ya))
                # normal_array[y, x,] <- c(0.0, round(ya, 6), 0.0)
                normal_array[(image_width + 1) - y, x,] <- c(normal_array[(image_width + 1) - y, x, 1], round(ya, 6), normal_array[(image_width + 1) - y, x, 3])
                normals[[i]] <- normal_array[(image_width + 1) - y, x,]
            }
        }
    }

    print("normals:")
    print(length(normals))
    print(length(normals[[1]]))
    print(length(normal_array[,,1]))    # total sets of normal coords
    print(length(normal_array[,1,1]))   # normal coords per image row
    print(length(normal_array[1,1,]))   # normal coordinate dimensions
    list(
        heights = height_array,
        vertices = vertices,
        normals = normals,
        normal_array = normal_array,
        textureCoords = textureCoords
    )
}

image_width <- length(image_gray[1,])
image_height <- length(image_gray[, 1])
map <- mapTerrainCoords(image_gray, image_width, image_height)

heights <- map$heights
vertices <- map$vertices
normals <- map$normals
textureCoords <- map$textureCoords
```

```{r heigt_data, cache = TRUE, echo = FALSE, results = "asis"}
# print without tabs so R markdown will add it to the DOM tree of the resulting page
cat(paste('<div id="data_in_html"><script type="application/json">', jsonlite::toJSON(heights), '\n</script>\n</div>', sep=""))
```

```{r normal_preview, cache = TRUE, echo = FALSE, results = "asis"}
if (file.exists("data")) {
   normal_test_file <- "data/planar-terrain-normals.png"
} else {
    normal_test_file <- file.choose(new = TRUE)
}

# test write to png
png::writePNG(map$normal_array, normal_test_file)

cat(paste0('<img id="heightmap" src="/post/', normal_test_file, '" style="float: right; width:256px; padding: 1%;" />'))
```

The ray-tracing-based shade algorithm that I will use of this comes from the blog post [Throwing Shade at the Cartographer Illuminati](https://www.tylermw.com/throwing-shade/) by Tyler Morgan-Wall.
<br />

```{r throwing_shade, cache = FALSE, echo = TRUE, results= "asis"}
if (!require(akima) || !require(reshape2) || !require(viridis)) {
    install.packages(c("akima", "ggplot2", "reshape2", "viridis"))
}

library(akima)
library(ggplot2)
library(reshape2)
library(viridis)

volcanoshadow <- matrix(1, ncol = ncol(volcano), nrow = nrow(volcano))

volc <- list(x=1:nrow(volcano), y=1:ncol(volcano), z=volcano)
sunangle <- 45 / 180*pi
angle <- -90 / 180 * pi
diffangle <- 90 / 180 * pi
numberangles <- 25
anglebreaks <- seq(angle, diffangle, length.out = numberangles)
maxdistance <- floor(sqrt(ncol(volcano)^2 + nrow(volcano)^2))

for (i in 1:nrow(volcano)) {
  for (j in 1:ncol(volcano)) {
    for (anglei in anglebreaks) {
      for (k in 1:maxdistance) {
        xcoord <- (i + sin(sunangle)*k)
        ycoord <- (j + cos(sunangle)*k)
        if(xcoord > nrow(volcano) ||
           ycoord > ncol(volcano) ||
           xcoord < 0 || ycoord < 0) {
          break
        } else {
          tanangheight <- volcano[i, j] + tan(anglei) * k
          if (all(c(volcano[ceiling(xcoord), ceiling(ycoord)],
                    volcano[floor(xcoord), ceiling(ycoord)],
                    volcano[ceiling(xcoord), floor(ycoord)],
                    volcano[floor(xcoord), floor(ycoord)]) < tanangheight)) next
          if (tanangheight < bilinear(volc$x,volc$y,volc$z,x0=xcoord,y0=ycoord)$z) {
            volcanoshadow[i, j] <- volcanoshadow[i, j] - 1 / length(anglebreaks)
            break
          }
        }
      }
    }
  }
}

ggplot() +
  geom_tile(data=melt(volcanoshadow), aes(x=Var1,y=Var2,fill=value)) +
  scale_x_continuous("X coord",expand=c(0,0)) +
  scale_y_continuous("Y coord",expand=c(0,0)) +
  scale_fill_viridis() +
  theme_void() +
  theme(legend.position = "none")
```


```{r idx_knit_for_loop, cache = TRUE, echo = TRUE}

knitTriangleIndices <- function(img_width, img_height) {
    indices <- c()
    width <- img_width - 1
    row <- 1

    for (r in 1:(img_height - 1)) {
        offset <- (img_width * (row - 1))
        while (width > 0) {
            idx1 <- (width - 1) + offset
            idx2 <- (width + img_width) + offset
            idx3 <- (width + (img_width - 1)) + offset

            idx4 <- (width + img_width) + offset
            idx5 <- (width - 1) + offset
            idx6 <- (width) + offset

            indices <- c(indices, idx1, idx2, idx3, idx4, idx5, idx6)

            width <- (width - 1)
        }
        width <- img_width - 1
        row <- row + 1
    }

    indices
}

```

Finally, all of this data must be saved to json and then stitched together into a JS module which defines a new `terrain` (heightmap) object that can be imported by [`@sveltejs/gl`](https://github.com/Real-Currents/SvelteGL/tree/real/currents), with the form:
<pre><code>
    new Geometry({
        position: {
            data: new Float32Array([ /* array of vertices ... */ ]
                .flat(Infinity)),
            size: 3
        },

        normal: {
            data: new Float32Array([ /* array of normals ... */ ]
                .flat(Infinity)),
            size: 3
        },

        uv: {
            data: new Float32Array([ /* array of textureCoords ... */ ]
                .flat(Infinity)),
            size: 2
        }
    }, {
        index: new Uint32Array([ /* array of indices returned by knitTriangleIndices */ ]
        )
    });

</code></pre>

Now this turns out to be a [ginormous MJS file](/post/data/terrain.mjs) (~ 20MB), so I will ultimately use the smaller heightmap as the basis of `terrain` object imported by `@sveltejs/gl`. However, I will use the higher density height data exported by the normalmap (the blue PNG above) as well as create a json file for reference and use it to place the markers on the terrain later:

```{r json_write, cache = FALSE}
jsonlite::write_json(heights, "data/planar-terrain-heights.json")
jsonlite::write_json(vertices, "data/planar-terrain-verts.json")
jsonlite::write_json(normals, "data/planar-terrain-norms.json")
jsonlite::write_json(textureCoords, "data/planar-terrain-uvs.json")
jsonlite::write_json(knitTriangleIndices(image_width, image_height), "data/planar-terrain-idx.json")
```
