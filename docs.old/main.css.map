{
  "version": 3,
  "file": "main.css",
  "sources": [
    "../Layer.svelte",
    "../Overlay.svelte",
    "../Scene.svelte",
    "../App.svelte",
    "../GLSLApp.svelte",
    "../InvoiceApp.svelte",
    "../TechApp.svelte",
    "../TerrainApp.svelte",
    "../Controls.svelte",
    "../Keypad.svelte",
    "../NavigationControls.svelte",
    "../Clients.svelte",
    "../Emitter.svelte",
    "../Work.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport { get_layer, set_layer } from '../internal/index.mjs';\n\n\texport let index = undefined;\n\n\tset_layer(get_layer().add_child(index));\n</script>\n\n<div class=\"layer\">\n\t<slot></slot>\n</div>\n\n<style>\n\t/* for overlays, create a stacking context */\n\t.layer {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n</style>",
    "<script>\n\timport Point from './Point.svelte';\n\n\texport let location;\n\texport let direction = undefined;\n\texport let snap = false;\n\n\t$: px = n => `${snap ? Math.round(n) : n}px`;\n</script>\n\n<Point {location} {direction} let:x let:y let:vector>\n\t<span\n\t\tclass=\"overlay\"\n\t\tstyle=\"transform: translate3d({px(x)}, {px(y)}, 0)\"\n\t>\n\t\t<slot vector={vector}></slot>\n\t</span>\n</Point>\n\n<style>\n\t.overlay {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\tuser-select: none;\n\t\t-moz-user-select: none;\n\t\twill-change: transform;\n\t}\n</style>",
    "<script context=\"module\">\n\timport { readable } from 'svelte/store';\n\n\tfunction is_intersecting(el) {\n\t\t// TODO this shouldn't be necessary. But the initial value\n\t\t// of entry.isIntersecting in an IO can be incorrect, it\n\t\t// turns out? need to investigate further\n\t\tconst bcr = el.getBoundingClientRect();\n\n\t\treturn (\n\t\t\tbcr.bottom > 0 &&\n\t\t\tbcr.right  > 0 &&\n\t\t\tbcr.top    < window.innerHeight &&\n\t\t\tbcr.left   < window.innerWidth\n\t\t);\n\t}\n\n\tfunction get_visibility(node) {\n\t\treturn readable(false, set => {\n\t\t\tif (typeof IntersectionObserver !== 'undefined') {\n\t\t\t\tconst observer = new IntersectionObserver(entries => {\n\t\t\t\t\t// set(entries[0].isIntersecting);\n\t\t\t\t\tset(is_intersecting(node));\n\t\t\t\t});\n\n\t\t\t\tobserver.observe(node);\n\t\t\t\treturn () => observer.unobserve(node);\n\t\t\t}\n\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tfunction handler() {\n\t\t\t\t\tconst { top, bottom } = node.getBoundingClientRect();\n\t\t\t\t\tset(bottom > 0 && top < window.innerHeight);\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener('scroll', handler);\n\t\t\t\twindow.addEventListener('resize', handler);\n\n\t\t\t\treturn () => {\n\t\t\t\t\twindow.removeEventListener('scroll', handler);\n\t\t\t\t\twindow.removeEventListener('resize', handler);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n</script>\n\n<script>\n\timport { setContext, onMount, onDestroy, tick } from 'svelte';\n\timport { writable } from 'svelte/store';\n\timport { RENDERER, LAYER, PARENT, CAMERA, create_layer } from '../internal/index.mjs';\n\timport { create_worker, process_color } from '../internal/utils.mjs';\n\timport * as mat4 from 'gl-matrix/mat4';\n\timport * as vec3 from 'gl-matrix/vec3';\n\n\texport let background = [1, 1, 1];\n\texport let backgroundOpacity = 1;\n\texport let fog = undefined;\n\texport let pixelRatio = undefined;\n\n\tconst use_fog = 'fog' in $$props;\n\n\t$: bg = process_color(background);\n\n\tlet canvas;\n\tlet visible = writable(false);\n\tlet pending = false;\n\tlet update_scheduled = false;\n\tlet w;\n\tlet h;\n\n\texport let gl; // WebGL2RenderingContext\n\texport let process_extra_shader_components; // (gl, material) => {}\n\tlet draw = () => {};\n\tlet camera_stores = {\n\t\tcamera_matrix: writable(),\n\t\tview: writable(),\n\t\tprojection: writable()\n\t};\n\n\tconst invalidate = typeof window !== 'undefined'\n\t\t? () => {\n\t\t\tif (!update_scheduled) {\n\t\t\t\tupdate_scheduled = true;\n\t\t\t\trequestAnimationFrame(draw);\n\t\t\t}\n\t\t}\n\t\t: () => {};\n\n\tconst width = writable(1);\n\tconst height = writable(1);\n\n\tconst root_layer = create_layer(0, invalidate);\n\n\tconst default_camera = { /* TODO */ };\n\tlet camera = default_camera;\n\tconst num_lights = 8;\n\n\tconst meshes = [];\n\n\t// lights\n\tconst lights = {\n\t\tambient: [],\n\t\tdirectional: [],\n\t\tpoint: []\n\t};\n\n\tfunction add_to(array) {\n\t\treturn fn => {\n\t\t\tarray.push(fn);\n\t\t\tinvalidate();\n\n\t\t\tonDestroy(() => {\n\t\t\t\tconst i = array.indexOf(fn);\n\t\t\t\tif (~i) array.splice(i, 1);\n\t\t\t\tinvalidate();\n\t\t\t});\n\t\t}\n\t}\n\n\tconst targets = new Map();\n\tlet camera_position_changed_since_last_render = true;\n\n\tconst scene = {\n\t\tdefines: [\n\t\t\t`#define NUM_LIGHTS 2\\n` + // TODO configure this\n\t\t\t`#define USE_FOG ${use_fog}\\n`\n\t\t].join(''),\n\n\t\tadd_camera: _camera => {\n\t\t\tif (camera && camera !== default_camera) {\n\t\t\t\tthrow new Error(`A scene can only have one camera`);\n\t\t\t}\n\n\t\t\tcamera = _camera;\n\t\t\tinvalidate();\n\n\t\t\t// TODO this is garbage\n\t\t\tcamera_stores.camera_matrix.set(camera.matrix);\n\t\t\tcamera_stores.projection.set(camera.projection);\n\t\t\tcamera_stores.view.set(camera.view);\n\n\t\t\tonDestroy(() => {\n\t\t\t\tcamera = default_camera;\n\t\t\t\tinvalidate();\n\t\t\t});\n\t\t},\n\n\t\tupdate_camera: camera => {\n\t\t\t// for overlays\n\t\t\tcamera_stores.camera_matrix.set(camera.matrix);\n\t\t\tcamera_stores.view.set(camera.view);\n\t\t\tcamera_stores.projection.set(camera.projection);\n\n\t\t\tcamera_position_changed_since_last_render = true;\n\t\t\tinvalidate();\n\t\t},\n\n\t\tadd_directional_light: add_to(lights.directional),\n\t\tadd_point_light: add_to(lights.point),\n\t\tadd_ambient_light: add_to(lights.ambient),\n\n\t\tget_target(id) {\n\t\t\tif (!targets.has(id)) targets.set(id, writable(null));\n\t\t\treturn targets.get(id);\n\t\t},\n\n\t\tinvalidate,\n\n\t\t...camera_stores,\n\n\t\twidth,\n\t\theight\n\t};\n\n\tsetContext(RENDERER, scene);\n\tsetContext(LAYER, root_layer);\n\n\tconst origin = mat4.identity(mat4.create());\n\tconst ctm = writable(origin);\n\tsetContext(PARENT, {\n\t\tget_matrix_world: () => origin,\n\t\tctm: { subscribe: ctm.subscribe }\n\t});\n\n\tonMount(() => {\n\t\tscene.canvas = canvas;\n\t\tgl = scene.gl = canvas.getContext('webgl2');\n\t\tvisible = get_visibility(canvas);\n\n\t\tgl.clearColor(0.0, 0.0, 0.0, 0.0);\n\n\t\t// const extensions = [\n\t\t// \t'OES_element_index_uint',\n\t\t// \t'OES_standard_derivatives'\n\t\t// ];\n\t\t//\n\t\t// extensions.forEach(name => {\n\t\t// \tconst ext = gl.getExtension(name);\n\t\t// \tif (!ext) {\n\t\t// \t\tthrow new Error(`Unsupported extension: ${name}`);\n\t\t// \t}\n\t\t// });\n\n\t\tdraw = force => {\n\t\t\tif (!camera) return; // TODO make this `!ready` or something instead\n\n\t\t\tif (dimensions_need_update) {\n\t\t\t\tconst DPR = pixelRatio || window.devicePixelRatio || 1;\n\t\t\t\tcanvas.width = $width * DPR;\n\t\t\t\tcanvas.height = $height * DPR;\n\t\t\t\tgl.viewport(0, 0, $width * DPR, $height * DPR);\n\n\t\t\t\tdimensions_need_update = false;\n\t\t\t}\n\n\t\t\tupdate_scheduled = false;\n\n\t\t\tif (!$visible && !force) {\n\t\t\t\tpending = true;\n\t\t\t\treturn;\n\t\t\t};\n\n\t\t\tpending = false;\n\n\t\t\t// gl.clearColor(...bg, backgroundOpacity);\n\t\t\t// gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\tgl.enable(gl.BLEND);\n\t\t\tgl.enable(gl.CULL_FACE);\n\t\t\tgl.enable(gl.DEPTH_TEST);                               // Enable depth testing\n\t\t\tgl.depthFunc(gl.LEQUAL);                                // Near things obscure far things\n\n\t\t\t// Clear the canvas before we start drawing on it.\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n\t\t\t// calculate total ambient light\n\t\t\tconst ambient_light = lights.ambient.reduce((total, { color, intensity }) => {\n\t\t\t\treturn [\n\t\t\t\t\tMath.min(total[0] + color[0] * intensity, 1),\n\t\t\t\t\tMath.min(total[1] + color[1] * intensity, 1),\n\t\t\t\t\tMath.min(total[2] + color[2] * intensity, 1)\n\t\t\t\t];\n\t\t\t}, new Float32Array([0, 0, 0]));\n\n\t\t\tlet previous_program;\n\n\t\t\tlet previous_state = {\n\t\t\t\t[gl.DEPTH_TEST]: null,\n\t\t\t\t[gl.CULL_FACE]: null\n\t\t\t};\n\n\t\t\tconst enable = (key, enabled) => {\n\t\t\t\tif (previous_state[key] !== enabled) {\n\t\t\t\t\tif (enabled) gl.enable(key);\n\t\t\t\t\telse gl.disable(key);\n\n\t\t\t\t\tprevious_state[key] = enabled;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfunction render_mesh({\n\t\t\t\tmodel,\n\t\t\t\tmodel_inverse_transpose,\n\t\t\t\tgeometry,\n\t\t\t\tmaterial,\n\t\t\t\tdepthTest,\n\t\t\t\tdoubleSided\n\t\t\t}) {\n\t\t\t\t// TODO should this even be possible?\n\t\t\t\tif (!material) return;\n\n\t\t\t\tenable(gl.DEPTH_TEST, depthTest !== false);\n\t\t\t\tenable(gl.CULL_FACE, doubleSided !== true);\n\n\t\t\t\tgl.blendFuncSeparate(\n\t\t\t\t\tgl.SRC_ALPHA, // source rgb\n\t\t\t\t\tgl.ONE_MINUS_SRC_ALPHA, // dest rgb\n\t\t\t\t\tgl.SRC_ALPHA, // source alpha\n\t\t\t\t\tgl.ONE // dest alpha\n\t\t\t\t);\n\n\t\t\t\t// set attributes\n\t\t\t\tgeometry.set_attributes(gl);\n\n\t\t\t\tif (material.program !== previous_program) {\n\t\t\t\t\tprevious_program = material.program;\n\n\t\t\t\t\t// TODO move logic to the mesh/material?\n\t\t\t\t\tgl.useProgram(material.program);\n\n\t\t\t\t\t// set built-ins\n\t\t\t\t\tgl.uniform3fv(material.uniform_locations.AMBIENT_LIGHT, ambient_light);\n\n\t\t\t\t\tif (use_fog) {\n\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.FOG_COLOR, bg);\n\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.FOG_DENSITY, fog);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (material.uniform_locations.DIRECTIONAL_LIGHTS) {\n\t\t\t\t\t\tfor (let i = 0; i < num_lights; i += 1) {\n\t\t\t\t\t\t\tconst light = lights.directional[i];\n\t\t\t\t\t\t\tif (!light) break;\n\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.DIRECTIONAL_LIGHTS[i].direction, light.direction);\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.DIRECTIONAL_LIGHTS[i].color, light.color);\n\t\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.DIRECTIONAL_LIGHTS[i].intensity, light.intensity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (material.uniform_locations.POINT_LIGHTS) {\n\t\t\t\t\t\tfor (let i = 0; i < num_lights; i += 1) {\n\t\t\t\t\t\t\tconst light = lights.point[i];\n\t\t\t\t\t\t\tif (!light) break;\n\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.POINT_LIGHTS[i].location, light.location);\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.POINT_LIGHTS[i].color, light.color);\n\t\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.POINT_LIGHTS[i].intensity, light.intensity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.uniform3fv(material.uniform_locations.CAMERA_WORLD_POSITION, camera.world_position);\n\t\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.VIEW, false, camera.view);\n\t\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.PROJECTION, false, camera.projection);\n\t\t\t\t}\n\n\t\t\t\t// set mesh-specific built-in uniforms\n\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.MODEL, false, model);\n\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.MODEL_INVERSE_TRANSPOSE, false, model_inverse_transpose);\n\n\t\t\t\tif (typeof process_extra_shader_components == 'function') {\n\t\t\t\t\t// set material-specific built-in uniforms\n\t\t\t\t\tmaterial.apply_uniforms(gl, null, model, process_extra_shader_components);\n\n\t\t\t\t} else {\n\t\t\t\t\t// set material-specific built-in uniforms\n\t\t\t\t\tmaterial.apply_uniforms(gl);\n\t\t\t\t}\n\n\t\t\t\t// draw\n\t\t\t\tif (geometry.index) {\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.buffers.__index);\n\t\t\t\t\tgl.drawElements(gl[geometry.primitive], geometry.index.length, gl.UNSIGNED_INT, 0);\n\t\t\t\t} else {\n\t\t\t\t\t// if (geometry.primitive === 'POINTS') {\n\t\t\t\t\t// \tconsole.log(\"If \", (gl[geometry.primitive] === gl.POINTS));\n\t\t\t\t\t// \tconsole.log(\"Draw gl.POINTS for \" + geometry.count + \" point(s)\" );\n\t\t\t\t\t// }\n\t\t\t\t\tconst primitiveType = gl[geometry.primitive];\n\t\t\t\t\tgl.drawArrays(primitiveType, 0, geometry.count);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction render_layer(layer) {\n\t\t\t\tif (layer.needs_sort) {\n\t\t\t\t\tlayer.child_layers.sort((a, b) => a.index - b.index);\n\t\t\t\t\tlayer.needs_sort = false;\n\t\t\t\t}\n\n\t\t\t\tgl.depthMask(true);\n\t\t\t\tgl.clearDepth(1.0);\n\t\t\t\tgl.clear(gl.DEPTH_BUFFER_BIT);\n\n\t\t\t\tfor (let i = 0; i < layer.meshes.length; i += 1) {\n\t\t\t\t\trender_mesh(layer.meshes[i]);\n\t\t\t\t}\n\n\t\t\t\t// TODO sort transparent meshes, furthest to closest\n\t\t\t\tgl.depthMask(false);\n\n\t\t\t\tif (camera_position_changed_since_last_render || layer.needs_transparency_sort) {\n\t\t\t\t\tsort_transparent_meshes(layer.transparent_meshes);\n\t\t\t\t\tlayer.needs_transparency_sort = false;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < layer.transparent_meshes.length; i += 1) {\n\t\t\t\t\trender_mesh(layer.transparent_meshes[i]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < layer.child_layers.length; i += 1) {\n\t\t\t\t\trender_layer(layer.child_layers[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trender_layer(root_layer);\n\t\t\tcamera_position_changed_since_last_render = false;\n\t\t};\n\n\t\t// for some wacky reason, Adblock Plus seems to prevent the\n\t\t// initial dimensions from being correctly reported\n\t\tconst timeout = setTimeout(() => {\n\t\t\t$width = canvas.clientWidth;\n\t\t\t$height = canvas.clientHeight;\n\t\t});\n\n\t\ttick().then(() => draw(true));\n\n\t\treturn () => {\n\t\t\tgl.getExtension('WEBGL_lose_context').loseContext();\n\t\t\tclearTimeout(timeout);\n\t\t};\n\t});\n\n\tconst sort_transparent_meshes = meshes => {\n\t\tif (meshes.length < 2) return;\n\n\t\tconst lookup = new Map();\n\t\tconst out = new Float32Array(16);\n\n\t\tmeshes.forEach(mesh => {\n\t\t\tconst z = mat4.multiply(out, camera.view, mesh.model)[14];\n\t\t\tlookup.set(mesh, z);\n\t\t});\n\n\t\tmeshes.sort((a, b) => lookup.get(a) - lookup.get(b));\n\t};\n\n\tlet dimensions_need_update = true;\n\n\tconst update_dimensions = () => {\n\t\tdimensions_need_update = true;\n\t\tinvalidate();\n\t};\n\n\t$: ($width, $height, update_dimensions());\n\t$: (background, backgroundOpacity, fog, scene.invalidate());\n\t$: if ($visible && pending) scene.invalidate();\n</script>\n\n<style>\n\t.container, canvas {\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tdisplay: block;\n\t\toverflow: hidden;\n\t}\n</style>\n\n<div class=\"container\" bind:clientWidth={$width} bind:clientHeight={$height}>\n\t<canvas bind:this={canvas}></canvas>\n\n\t{#if gl}\n\t\t<slot width={$width} height={$height}></slot>\n\t{/if}\n</div>\n",
    "<script>\n\timport { onMount } from 'svelte';\n\n\texport let greeting;\n\n\tlet pin;\n\tlet view;\n\tview = pin ? pin.replace(/\\d(?!$)/g, '*') : 'enter your pin';\n\n\tfunction handleSubmit() {\n\t\talert(`submitted ${pin}`);\n\t}\n\n\tlet canvas;\n\n\tconst width = () => (!!canvas && !!canvas.width) ? canvas.width : 32;\n\tconst height = () => (!!canvas && !!canvas.height) ? canvas.height : 32;\n\n\twindow.sBuffer = [];\n\twindow.fftReady = false;\n\twindow.fftProgress = -1;\n\twindow.fftLoader = 0;\n\twindow.appStarted = false;\n\twindow.appDelay = 0;\n\n\tconst statsBox = document.createElement('div');\n\tstatsBox.id = 'statBox';\n\tstatsBox.style.display = \"flex\";\n\tstatsBox.style.flexDirection = \"column\";\n\tstatsBox.style.top = \"50%\";\n\tstatsBox.style.alignItems = \"center\";\n\tstatsBox.style.width = statsBox.style.height = \"100%\";\n\tstatsBox.style.position = \"fixed\";\n\tstatsBox.style.marginTop = \"auto\";\n\tstatsBox.style.marginLeft = \"auto\";\n\tstatsBox.style.marginRight = \"auto\";\n\tstatsBox.style.color = \"#FFFFFF\";\n\tstatsBox.style.textAlign = \"center\";\n\tstatsBox.style.left = 0;\n\tstatsBox.innerHTML = ( location.pathname.match(/(\\.html)/)!==null )?\n\t\t\t'<img src=\"images/bw-loader.gif\" /><br />Loading... ':\n\t\t\t'<img src=\"images/bw-loader.gif\" /><br />Loading... ';\n\n\tfunction canvasApp (cv) {\n\t\twindow.canvasApp = canvasApp;\n\n\t\t/* START Global Vars */\n\t\twindow.audio = window.aud1;\n\t\twindow.audioLoad = false;\n\t\twindow.audioReady = false;\n\t\twindow.audioName = audio.children[0].src.match(/[\\/|\\\\]*([\\w|\\-|]+)\\.\\w\\w\\w$/)[1];\n\t\twindow.audio.onloadstart = (typeof audio.onloadstart === \"object\")?\n\t\t\t\tfunction() { audioLoad = true; return audioLoad; } :\n\t\t\t\t(function(){ audioLoad = true; return {audioLoad:true}; })();\n\t\twindow.audio.oncanplaythrough = (typeof audio.oncanplaythrough === \"object\")?\n\t\t\t\tfunction() {\n\t\t\t\t\tDebugger.log(\"audio is ready\");\n\t\t\t\t\taudioReady = true;\n\t\t\t\t\treturn audioReady;\n\t\t\t\t} :\n\t\t\t\t(function() {\n\t\t\t\t\t/*\n                    Debugger.log( \"Inline video is not supported\\n\" );\n                    return false;\n                    */\n\t\t\t\t\taudioReady = true;\n\t\t\t\t\treturn {audioReady:true};\n\t\t\t\t})();\n\n\t\twindow.addEventListener('keydown', function(event) {\n\t\t\tif(!event) var event = window.event; // cross-browser shenanigans\n\t\t\tif(event.keyCode === 32) { // this is the spacebar\n\t\t\t\tif (window.audio.paused) window.audio.play();\n\t\t\t\telse window.audio.pause();\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t\treturn true; // treat all other keys normally;\n\t\t});\n\t\t/* END Global Vars */\n\n\t\tcanvasApp.canDrawVideo = true;\n\n\t\t/* Get canvas properties */\n\t\tvar canvas = canvasApp.cv = (typeof canvasApp.cv === \"object\")?\n\t\t\t\t\t\tcanvasApp.cv:\n\t\t\t\t\t\tcv;\n\n\t\tDebugger.log( \"Using canvas '\"+ canvas.id +\"'\\n\" );\n\t\tcanvas.id = \"layer1\";\n\t\tcanvas.alt = \"Interactive Audio Visualizer\";\n\t\tcanvas.src = (location.pathname.match(/(\\.html)/) !== null)?\n\t\t\t\t\"visualizer.png\":\n\t\t\t\t\"http://\"+ window.location.host +\"/js-demos/visualizer.png\";\n\t\tcanvas.width = canvas.width || \"1024\";\n\t\tcanvas.height = canvas.height || \"576\";\n\t\tcanvas.setAttribute( 'onmouseover', 'canvasApp.mouseOver=true;' );\n\t\tcanvas.setAttribute( 'onmouseout', 'clearInterval(canvasApp.mouseEvent);canvasAppmouseOver=false;' );\n\t\tcanvas.setAttribute( 'onmousemove', 'canvasApp.colorChange(event);' );\n\t\tcanvasApp.mouseOver = false;\n\t\tcanvasApp.mouseEvent = 0;\n\t\tcanvasApp.tx = 0;\n\t\tcanvasApp.strokeStyle = (window['foreground01']) ? window['foreground01'].style.color : 'rgb(127,255,127)';\n\t\tcanvasApp.blockStyle = 'hsla(150,100%,100%,1.0)';\n\n\t\tcanvasApp.colorChange = function(evt){\n\t\t\tclearInterval(this.mouseEvent);\n\n\t\t\tvar strokeR = (window['foreground02']) ?\n\t\t\t\t\twindow['foreground02'].style.color.match(/rgb\\((\\d+)/)[1] :\n\t\t\t\t\t(canvasApp.blockStyle && canvasApp.blockStyle.match(/rgb\\((\\d+)/) !== null)?\n\t\t\t\t\t\t\tcanvasApp.blockStyle.match(/rgb\\((\\d+)/)[1] :\n\t\t\t\t\t\t\t\"hsl(180, 100%, 100%)\",\n\t\t\t\t\tstrokeB = (window['foreground03']) ?\n\t\t\t\t\t\t\twindow['foreground03'].style.color.match(/rgb\\(\\d+,[\\s|\\d]+,([\\s|\\d]+)/)[1] :\n\t\t\t\t\t\t\t(canvasApp.blockStyle && canvasApp.blockStyle.match(/rgb\\((\\d+)/) !== null)?\n\t\t\t\t\t\t\t\t\tcanvasApp.blockStyle.match(/rgb\\((\\d+)/)[1] :\n\t\t\t\t\t\t\t\t\t\"hsl(180, 100%, 100%)\";\n\n\t\t\tif( canvasApp.mouseOver ) window.mouseEvent = setTimeout( function(evt) {\n\t\t\t\tvar width = window.innerWidth,\n\t\t\t\t\t\theight = window.innerHeight;\n//\t\t \tDebugger.log( \"width: \"+ width +\" mouse x: \"+ evt.clientX );\n\t\t\t\tif (!strokeR) {\n\t\t\t\t\tstrokeR = 127;\n\t\t\t\t\tstrokeB = 255;\n\t\t\t\t} else {\n\t\t\t\t\tstrokeR = parseInt(strokeR/2);\n\t\t\t\t\tif( strokeR > 127 ) strokeR--;\n\t\t\t\t\tif( strokeR < 1 ) strokeR++;\n\t\t\t\t\tstrokeB = parseInt(strokeB);\n\t\t\t\t\tif( strokeB > 255 ) strokeB--;\n\t\t\t\t\tif( strokeB < 1 ) strokeB++;\n\t\t\t\t}\n\t\t\t\tif (evt.clientX > width/2) {\n\t\t\t\t\tcanvasApp.blockStyle = 'rgb('+ (strokeR++) +',127,'+ (strokeB++) +')';\n\t\t\t\t} else {\n\t\t\t\t\tcanvasApp.blockStyle = 'rgb('+ (strokeR--) +',127,'+ (strokeB--) +')';\n\t\t\t\t}\n//\t\t \tDebugger.log( canvasApp.strokeStyle );\n\t\t\t}, 33, evt);\n\n\t\t\treturn true;\n\t\t};\n\n\t\t/* Insert loader just after the canvas */\n\t\tif( document.getElementById('statBox') === null )\n\t\t\tcanvas.parentNode.appendChild(statsBox);\n\n\t\t/* Track fft amplitudes */\n\t\tvar amp1=0, amp2=0;\n\n\t\tif (!fftReady) {\n\t\t\tDebugger.log( \"Progress \"+ fftProgress.length +\"%\" );\n\t\t\tstatsBox.innerHTML = statsBox.innerHTML.match(/.+\\.\\.\\./)[0] + fftProgress.length +\"%\";\n\n\t\t\tif( fftProgress < 0 ) {\n\t\t\t\tfor( var p=fftProgress, z=10; p<z; p++) {\n\t\t\t\t\tcanvasApp.fftLoad(audioName, p, true);\n\t\t\t\t}\n\t\t\t\treturn appDelay = setTimeout(canvasApp, 333, canvasApp.cv);\n\n\t\t\t} else if (fftProgress.length > 9) {\n\t\t\t\tfftReady = true;\n\t\t\t\tstatsBox.parentNode.removeChild(statsBox);\n\n\t\t\t\tif (!!window.userTriggered) {\n\t\t\t\t\twindow.audio.play();\n\t\t\t\t\twindow.audio.currentTime=0;\n\t\t\t\t\twindow.audio.muted=false;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\treturn appDelay = setTimeout(canvasApp, 333, canvasApp.cv);\n\t\t\t}\n\n\t\t} else if(! audioReady ) {\n\t\t\t//Debugger.log( audioReady );\n\t\t\tif( audioLoad === false ) audio.load();\n\t\t\treturn appDelay = setTimeout(canvasApp, 333, canvasApp.cv);\n\t\t} else clearTimeout(appDelay);\n\t\tif( appStarted ) return appStarted;\n\n\t\tlet time = 0;\n\n\t\t/* Textual stuff */\n\t\tvar announcement = document.title;\n\t\tvar title = (window.text_title) ? window.text_title.innerHTML: \"Real~Currents\";\n\t\t//Debugger.log( title );\n\t\tvar copy = (window.text_copy) ? window.text_copy.innerHTML.split(/[\\n|\\r]/): \"\";\n\t\t//Debugger.log( copy );\n\n\t\t/* Audio visualization stuff */\n\t\tvar aidx = canvasApp.aidx = 0;\n\t\tvar aBuffer = canvasApp.aBuffer = [];\n\t\tvar fBuffer = canvasApp.fBuffer = [];\n\t\tvar vBuffer = canvasApp.vBuffer = [];\n\t\tvar w = canvas.width, h = canvas.height;\n\t\tvar hcorrect =  h / 2;\n\t\tif( sBuffer.length > 0 ) {\n\t\t\tfor( var i=1, z=sBuffer.length; i<z; i++ ) {\n\t\t\t\tvar a=[], f=[], v=[];\n\t\t\t\tif( typeof sBuffer[i] !== 'object' ) {\n\t\t\t\t\tDebugger.log( \"sBuffer has hole at \"+ i +\"\\n\" );\n\t\t\t\t\tfor( var p=0, z=11, buf=true; p<z; p++ ) {\n\t\t\t\t\t\tif( (p < 10) && (!fftProgress[p]) ) {\n\t\t\t\t\t\t\tbuf = false;\n\t\t\t\t\t\t\tcanvasApp.fftLoad(audioName, p, true);\n\t\t\t\t\t\t} else if(! buf ) {\n\t\t\t\t\t\t\tfftReady = false;\n\t\t\t\t\t\t\tappStarted = false;\n\t\t\t\t\t\t\tcanvas.parentNode.appendChild(statsBox);\n\t\t\t\t\t\t\treturn appDelay = setTimeout(canvasApp, 333, canvasApp.cv);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor( var j=0, n=sBuffer[i].length; j<n; j++ ) {\n\t\t\t\t\tvar afv = sBuffer[i][j].split(',');\n\t\t\t\t\t/* Draw a curve of the amplitude data */\n\t\t\t\t\tvar curveh = -afv[0]*hcorrect + hcorrect;\n\t\t\t\t\ta[j] = curveh;\n\t\t\t\t\tf[j] = afv[1];\n\t\t\t\t\tv[j] = afv[2];\n\n\t\t\t\t}\n\t\t\t\taBuffer.push(a);\n\t\t\t\tfBuffer.push(f);\n\t\t\t\tvBuffer.push(v);\n\t\t\t\t//Debugger.log( \"V*h=\"+ aBuffer[i-1]*canvas.height +\" w=\"+ canvas.width +\" h=\"+ canvas.height +\" \\n\" );\n\t\t\t}\n\t\t\tcanvasApp.fftLoad(audioName, 10);\n\t\t\t//Debugger.log( \"Total frames: \"+ (aBuffer.length) );\n\t\t} else for( var i=0, z=2000; i<z; i++ ) aBuffer.push(0.5);\n\n\t\tvar aCanvas = document.createElement('canvas');\n\t\tvar bCanvas = document.createElement('canvas');\n\t\taCanvas.width = bCanvas.width = w>>2; //aBuffer[0].length;\n\t\taCanvas.height = bCanvas.height = canvas.height;\n\t\tvar actx = canvasApp.actx = aCanvas.getContext('2d');\n\t\tvar bctx = canvasApp.bctx = bCanvas.getContext('2d');\n\n\t\t/* Draw main function */\n\n\t\tfunction draw (ctx, w, h) {\n\n\t\t\tvar actx = canvasApp.actx, bctx = canvasApp.bctx;\n\n\t\t\tfunction drawPictures (context, pictures) {\n\t\t\t\tvar pidx = 0,\n\t\t\t\t\t\tchange = 223;\n\n\t\t\t\tif( aidx > change ) pidx = parseInt(aidx/change)%(pictures.length);\n\t\t\t\tif( aidx < 10 ) {\n\t\t\t\t\tcontext.globalCompositeOperation = \"source-out\";\n\t\t\t\t\tcontext.globalAlpha = 0.05;\n\t\t\t\t} else if( aidx%change < 3 || (change - 3) < aidx%change) {\n\t\t\t\t\tcontext.globalCompositeOperation = \"source-out\";\n\t\t\t\t\tcontext.globalAlpha = 0.25;\n\t\t\t\t} else if( aidx%change < 6 || (change - 6) < aidx%change) {\n\t\t\t\t\tcontext.globalCompositeOperation = \"screen\";\n\t\t\t\t\tcontext.globalAlpha = 0.50;\n\t\t\t\t} else {\n\t\t\t\t\tcontext.globalCompositeOperation = \"source-in\";\n\t\t\t\t\tcontext.globalAlpha = 1.0;\n\t\t\t\t}\n\t\t\t\tcontext.drawImage(pictures[pidx], (canvas.width/2 - pictures[pidx].width), -40, pictures[pidx].width*2, pictures[pidx].height*2);\n\n\t\t\t}\n\n\t\t\tfunction drawVideo (context, video) {\n\t\t\t\tvar pidx = 0,\n\t\t\t\t\t\tchange = 223;\n\n\t\t\t\tif( aidx < 10 ) {\n\t\t\t\t\tcontext.globalCompositeOperation = \"source-out\";\n\t\t\t\t\tcontext.globalAlpha = 0.05;\n\t\t\t\t} else if( aidx%change < 3 || (change - 3) < aidx%change) {\n\t\t\t\t\tcontext.globalCompositeOperation = \"source-out\";\n\t\t\t\t\tcontext.globalAlpha = 0.25;\n\t\t\t\t} else if( aidx%change < 6 || (change - 6) < aidx%change) {\n\t\t\t\t\tcontext.globalCompositeOperation = \"screen\";\n\t\t\t\t\tcontext.globalAlpha = 0.50;\n\t\t\t\t} else {\n\t\t\t\t\tcontext.globalCompositeOperation = \"source-in\";\n\t\t\t\t\tcontext.globalAlpha = 1.0;\n\t\t\t\t}\n\n\t\t\t\t/* Draw video input, if any */\n\t\t\t\tif( window.canvasApp.canDrawVideo === true ) try {\n\t\t\t\t\tvar cCanvas = document.createElement('canvas');\n\t\t\t\t\tvar cctx = cCanvas.getContext('2d');\n\n\t\t\t\t\tcCanvas.width = canvas.width/2;\n\t\t\t\t\tcCanvas.height = canvas.height;\n\t\t\t\t\tcctx.globalAlpha = 1.0\n\n\t\t\t\t\tvar vx = cCanvas.width - video.videoWidth/2;\n\t\t\t\t\tvar vw = 3 * (video.videoHeight/canvas.height * canvas.width) / 2;\n\t\t\t\t\tvar vh = cCanvas.height;\n\t\t\t\t\tif ( (video != null) && (video.readyState > 2) && (!video.paused) )\n\t\t\t\t\t\tcctx.drawImage(video, vx/2, 0, vw, vh);\n\n\t\t\t\t\tctx.globalAlpha = 1.0;\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.drawImage(cCanvas, 0, 0, cCanvas.width, canvas.height);\n//            setTimeout(function () {\n\t\t\t\t\tctx.translate(w, 0);\n\t\t\t\t\tctx.scale(-1, 1);\n\t\t\t\t\tctx.drawImage(cCanvas, 0, 0, cCanvas.width, canvas.height);\n\t\t\t\t\tctx.restore();\n//            }, 1);\n\n//            cctx.drawImage(aCanvas, 1, 2, (w>>2)-1, h-4);\n//            cctx.fillStyle = \"rgba(0%,0%,0%,0.005)\";\n//            cctx.fillRect(0, 0, w, h);\n\n\t\t\t\t} catch (err) {\n\t\t\t\t\tDebugger.on = true;\n\t\t\t\t\tDebugger.log(\"Failed to draw \"+ video.id +\": \"+ err.stack);\n\t\t\t\t\twindow.canvasApp.canDrawVideo = false;\n\t\t\t\t\tDebugger.on = false;\n\t\t\t\t}\n\n\t\t\t\t// Debugger.log( \"time: \"+ time );\n\t\t\t}\n\n\t\t\tctx.globalCompositeOperation = \"source-over\";\n\t\t\tctx.globalAlpha = 1.0;\n\n\t\t\ttry {\n\t\t\t\tif( time%2 ) {\n\t\t\t\t\t//Debugger.on = true;\n\n\t\t\t\t\tbctx.clearRect(0, 0, w, h);\n\t\t\t\t\tcontext.globalCompositeOperation = \"source-over\";\n\t\t\t\t\tcontext.globalAlpha = 1.0;\n\n\t\t\t\t\tif( window.pictures && window.pictures.children.length > 0 ) {\n\t\t\t\t\t\tdrawPictures(ctx, window.pictures.children);\n\t\t\t\t\t\tctx.globalCompositeOperation = \"multiply\";\n\t\t\t\t\t\tctx.globalAlpha = 0.05;\n\n\t\t\t\t\t} else if( window.canvasApp.canDrawVideo === true ) {\n\t\t\t\t\t\tdrawVideo(actx, audio);\n\t\t\t\t\t\tctx.globalCompositeOperation = \"multiply\";\n\t\t\t\t\t\tctx.globalAlpha = 0.5;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor( var o = 6; o > 0; o-- ) {\n\t\t\t\t\t\taidx = canvasApp.aidx =\n\t\t\t\t\t\t\t\tgraphSamples(actx, audio, aBuffer, fBuffer, vBuffer, aidx, w, h, o);\n\t\t\t\t\t}\n\t\t\t\t\tctx.globalAlpha = 1.0;\n\t\t\t\t\tctx.drawImage(aCanvas, 0, 0, (w>>1), h);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.translate(w, 0);\n\t\t\t\t\tctx.scale(-1, 1);\n\t\t\t\t\tctx.drawImage(aCanvas, 0, 0, (w>>1), h);\n\t\t\t\t\tctx.restore();\n\n\t\t\t\t\tbctx.drawImage(aCanvas, 1, 2, (w>>2)-1, h-4);\n\t\t\t\t\tbctx.fillStyle = \"rgba(0%,0%,0%,0.005)\";\n\t\t\t\t\tbctx.fillRect(0, 0, w, h);\n\n\t\t\t\t} else {\n\t\t\t\t\tactx.clearRect(0, 0, w, h);\n\n\t\t\t\t\tactx.drawImage(bCanvas, 1, 2, (w>>2)-1, h-4);\n\t\t\t\t\tactx.fillStyle = (window['background02']) ? window['background02'].style.color : \"rgba(0%,0%,0%,0.025)\";\n\t\t\t\t\tactx.fillRect(0, 0, w, h);\n\t\t\t\t}\n\n\t\t\t} catch (err) {\n\n\t\t\t\tctx.globalCompositeOperation = \"source-over\";\n\t\t\t\tctx.globalAlpha = 1.0;\n\n\t\t\t\tDebugger.on = true;\n\t\t\t\tDebugger.log(\"Failed to draw: \"+ err.stack);\n\t\t\t\twindow.canvasApp.canDrawVideo = false;\n\t\t\t\tDebugger.on = false;\n\t\t\t}\n\n\t\t\tctx.globalCompositeOperation = \"source-over\";\n\t\t\tctx.globalAlpha = 1.0;\n\n\t\t\t/* Text */\n\t\t\tctx.lineWidth = 2;\n\t\t\tctx.fillStyle =  (window['foreground01']) ? window['foreground01'].style.color : \"hsl(180, 100%, 100%)\";\n\t\t\tctx.strokeStyle = (window['foreground02']) ? window['foreground02'].style.color : \"#fff\";\n\t\t\t//Debugger.log( \"aBuffer index: \"+ aidx );\n\t\t\tif( aidx < 100 ) {\n\t\t\t\tctx.font = \"bold \"+ aidx*2 +\"px Comfortaa\";\n\n\t\t\t\tif( aidx%2 === 0) {\n\t\t\t\t\tctx.fillText(announcement, 320 - aidx*4, h>>1);\n\t\t\t\t} else ctx.strokeText(announcement, 320 - aidx*4, h>>1);\n\n\t\t\t} else if( aidx > 300 ) {\n\t\t\t\tctx.font = \"bold 12px Verdana\";\n\t\t\t\tctx.fillText(title, 64, 128);\n\t\t\t\tif( (aidx > 1500) && (aidx < 3500) ) for(var i=0, z=copy.length; i<z; i++)\n\t\t\t\t\tctx.fillText(copy[i], w>>1, (2500 - aidx) + (i*20) );\n\t\t\t}\n\n\t\t\ttime++;\n\t\t\tif (time == \"undefined\") {\n\t\t\t\ttime = 0;\n\t\t\t}\n\n\t\t\t//Debugger.log( \"time: \"+ time );\n\t\t}\n\n\t\t/* Graph samples */\n\t\tfunction graphSamples( ctx, audio, abuf, fbuf, vbuf, aidx, w, h, o ) {\n\t\t\ttry {\n\t\t\t\tif( abuf.length < 1 ) return aidx;\n\t\t\t\tif( audio.paused ) return aidx;\n\t\t\t\tif(! (audio.readyState > 3) ) return aidx;\n\n\t\t\t\tvar idx = Math.floor( audio.currentTime*15.03 ) - 6;\n\t\t\t\tif(! abuf[parseInt(idx + o)] ) {\n\t\t\t\t\tDebugger.log( \"abuf[\"+ idx +\"] has not been recieved\\n\" );\n\t\t\t\t\treturn aidx;\n\t\t\t\t}\n\t\t\t\t//Debugger.log( \"aBuffer index: \"+ idx );\n\n\t\t\t\t/* Reset canvas ctx properties */\n\t\t\t\tctx.globalCompositeOperation = \"source-over\";\n\t\t\t\tctx.globalAlpha = 1.0;\n\t\t\t\tctx.font = \"bold 10px Verdana\";\n\t\t\t\tvar hcorrect =  h / 2;\n\t\t\t\t/* Plot each sample on line that moves from left to right\n                 * until we reach the end of the screen or the end of the sample\n                 */\n\t\t\t\tif( idx < 1 ) {\n\t\t\t\t\tctx.moveTo( 0, hcorrect );\n\t\t\t\t} else ctx.moveTo( 0, -(abuf[parseInt(idx + o)][0]*2*hcorrect) + hcorrect  );\n\n\t\t\t\tvar verts = 6,\n\t\t\t\t\t\thidx = parseInt(idx + o);\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tif( aidx%6 ) canvasApp.blockStyle = (window['foreground02']) ? window['foreground02'].style.color : \"hsl(180, 100%, 100%)\";\n\t\t\t\telse canvasApp.blockStyle = (window['foreground03']) ? window['foreground03'].style.color : \"hsl(180, 100%, 100%)\";\n\n\t\t\t\tctx.fillStyle = canvasApp.blockStyle.replace(/,\\s?0\\.\\d+\\)/, \",1.0)\");\n\n\t\t\t\tfor( var i=0, z=abuf[hidx].length, n=z; i<z; i++ ) {\n\t\t\t\t\t/* Draw a curve of the amplitude data */\n\t\t\t\t\tif( i > 0 ) {\n\t\t\t\t\t\tctx.strokeStyle = canvasApp.strokeStyle;\n\t\t\t\t\t\tctx.strokeWidth = canvasApp.strokeWidth;\n\t\t\t\t\t\tctx.quadraticCurveTo(\n\t\t\t\t\t\t\t\t(i-1)*4, abuf[hidx][i] + o,\n\t\t\t\t\t\t\t\ti*4, abuf[hidx][i] + o\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t/* Draw bars for the eq levels (fft) data */\n\t\t\t\t\tvar barh = h - vbuf[hidx][i]*h;\n\t\t\t\t\tamp2 = amp1;\n\t\t\t\t\tamp1 = (i === 3 && vbuf[hidx][i] > 0.05)? vbuf[hidx][i] : amp1;\n\t\t\t\t\tverts = (amp2 !== amp1)? parseInt(Math.random()*10) : verts;\n\t\t\t\t\tif( (i <= n) ) {\n\t\t\t\t\t\tvar freq = Math.floor(fbuf[hidx][i]);\n\t\t\t\t\t\t//ctx.fillStyle = \"hsl(\"+ (200 - vbuf[parseInt(idx + o)][i]*180) +\", 100%, 50%)\";\n\t\t\t\t\t\tctx.fillStyle = canvasApp.blockStyle.replace(\n\t\t\t\t\t\t\t\t/,\\s?0\\.\\d+\\)/,\n\t\t\t\t\t\t\t\t\",1.0)\"\n\t\t\t\t\t\t).replace(\n\t\t\t\t\t\t\t\t/hsla\\((150),\\s?(100)\\%,\\s?(70)\\%/,\n\t\t\t\t\t\t\t\t\"hsla($1, \"+ (vbuf[parseInt(idx + o)][i]*50) +\"%, $3%\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tctx.fillRect( i*4, barh, 4, h );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon(ctx, verts, idx%(w)-(w>>3), idx%(h), (parseFloat(amp2+amp1)/2)*w, idx, 0);\n\t\t\t\tctx.stroke();\n\n\t\t\t\treturn ++idx;\n\n\t\t\t} catch(e) {\n\t\t\t\tDebugger.log( \"graphSamples failed: \" + e.message +\" at frame \"+ aidx +\"\\n\"+ e.stack );\n\t\t\t\treturn aidx;\n\t\t\t}\n\t\t}\n\n\t\t/* Draw polygons */\n\t\tfunction polygon(c, n, x, y, r, angle, counterclockwise, order) {\n\t\t\tvar order = order || null;\n\t\t\tif (order === (null || \"first\")) {\n\t\t\t\tc.beginPath();\n\t\t\t}\n\t\t\tvar angle = angle || 0;\n\t\t\tvar counterclockwise = counterclockwise || false;\n\t\t\t//Compute vertex position and begin a subpath there\n\t\t\tc.moveTo(x + r*Math.sin(angle),\n\t\t\t\t\ty - r*Math.cos(angle));\n\t\t\tvar delta = 2*Math.PI/n;\n\t\t\t//For remaining verts,\n\t\t\tfor (var i=1; i < n; i++) {\n\t\t\t\t//compute angle of this vertex,\n\t\t\t\tangle += counterclockwise ? -delta : delta;\n\t\t\t\t//then compute position of vertex and add line\n\t\t\t\tc.lineTo(x + r*Math.sin(angle),\n\t\t\t\t\t\ty - r*Math.cos(angle));\n\t\t\t}\n\t\t\t//Connect last vertex back to first\n\t\t\tc.closePath();\n\n\t\t\tif (order === (null || \"last\")) {\n\t\t\t\t//Fill the poly\n\t\t\t\tc.fill();\n\t\t\t\t//Outline the poly\n\t\t\t\tc.stroke();\n\t\t\t}\n\t\t}\n\n\t\t/* Begin draw loop */\n\t\ttry {\n\t\t\tvar context = canvas.getContext('2d');\n\t\t\ttime = 0;\n\t\t\tdrawLoop = setInterval(draw, 31, context, canvas.width, canvas.height);\n\t\t\tDebugger.log(\"Draw loop started\");\n\t\t\tappStarted = true;\n\t\t\treturn appStarted;\n\t\t} catch(e) {\n\t\t\tDebugger.log(\"drawLoop failed to start\");\n\n\t\t}\n\t}\n\n\tcanvasApp.fftLoad = function (aname, pr, single) {\n\t\t//audio.load();\n\t\tvar part;\n\t\tif( pr < 0 ) {\n\t\t\tfftProgress = [];\n\t\t\tpart = fftProgress.length;\n\t\t} else {\n\t\t\tpart = pr;\n\t\t}\n\n\t\tif( (pr > 99) || (part > 99) ) {\n\t\t\tclearTimeout(fftLoader);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tvar sr = document.createElement('script');\n\t\t\tsr.src = (part < 10) ?\n\t\t\t\t\t\"https://s3-us-west-1.amazonaws.com/real-currents/js-demos/data/\" + aname + \"-0\" + part + \".js\" :\n\t\t\t\t\t\"https://s3-us-west-1.amazonaws.com/real-currents/js-demos/data/\" + aname + \"-\" + part + \".js\";\n\t\t\tdocument.body.appendChild(sr);\n\t\t\tif( (part < 99) && (!single) )\n\t\t\t\tfftLoader = setTimeout(canvasApp.fftLoad, 99, aname, ++part);\n\t\t}\n\t\treturn true;\n\t};\n\n\tcanvasApp.updateFFT = function(prog) {\n\t\tsetTimeout( function(prog) {\n\t\t\tfftProgress[prog] = true;\n\t\t\tDebugger.log( fftProgress[prog] );\n\t\t\tvar aidx = canvasApp.aidx;\n\t\t\tvar aBuffer = canvasApp.aBuffer;\n\t\t\tvar fBuffer = canvasApp.fBuffer;\n\t\t\tvar vBuffer = canvasApp.vBuffer;\n\t\t\tvar firstBreak = false;\n\t\t\tvar w = canvasApp.cv.width, h = canvasApp.cv.height;\n\t\t\tvar hcorrect =  h / 2;\n\t\t\tif(\n\t\t\t\t\ttypeof sBuffer !== 'object' ||\n\t\t\t\t\ttypeof aBuffer !== 'object' ||\n\t\t\t\t\ttypeof fBuffer !== 'object' ||\n\t\t\t\t\ttypeof vBuffer !== 'object'\n\t\t\t) return Debugger.log( \"canvas Buffers are undefined\");\n\t\t\tDebugger.log( \"Progress \"+ fftProgress.length +\"%\" );\n\t\t\tif( fftProgress.length < 10 ) return;\n\n\t\t\tif( sBuffer.length > 0 ) {\n\t\t\t\tvar idx = ( aidx > aBuffer.length )? aidx: (aBuffer.length-1);\n\t\t\t\tfor( var i=0, z=aBuffer.length; i<z; i++ ) {\n\t\t\t\t\tif(! aBuffer[i] ) {\n\t\t\t\t\t\tidx = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor( var i=idx, z=sBuffer.length; i<z; i++ ) {\n\t\t\t\t\tvar a=[], f=[], v=[];\n\t\t\t\t\tif( (typeof sBuffer[i] !== 'object') ) {\n\t\t\t\t\t\tif(! firstBreak ) {\n\t\t\t\t\t\t\tDebugger.log( \"sBuffer has hole at \"+ i +\"\\n\" );\n\t\t\t\t\t\t\tfor( var p in fftProgress ) {\n\t\t\t\t\t\t\t\tif( (p < prog) && (!fftProgress[p]) )\n\t\t\t\t\t\t\t\t\tcanvasApp.fftLoad(audioName, p, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfirstBreak = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor( var j=0, n=sBuffer[i].length; j<n; j++ ) {\n\t\t\t\t\t\tvar afv = sBuffer[i][j].split(',');\n\t\t\t\t\t\t/* Draw a curve of the amplitude data */\n\t\t\t\t\t\tvar curveh = -afv[0]*hcorrect + hcorrect;\n\t\t\t\t\t\ta[j] = curveh;\n\t\t\t\t\t\tf[j] = afv[1];\n\t\t\t\t\t\tv[j] = afv[2];\n\t\t\t\t\t}\n\t\t\t\t\taBuffer.push(a);\n\t\t\t\t\tfBuffer.push(f);\n\t\t\t\t\tvBuffer.push(v);\n\t\t\t\t}\n\t\t\t\tDebugger.log( \"Total frames: \"+ (aBuffer.length) );\n\t\t\t}\n\t\t}, 66, prog);\n\t};\n\n\tonMount(() => {\n\t\tconst ctx = canvas.getContext(\"2d\");\n\t\tctx.fillStyle = \"#00f\";\n\t\tctx.fillRect(0, 0, canvas.width, canvas.height);\n\t\tctx.fillStyle = \"#fff\";\n\t\tctx.font = \"20px Arial\";\n\t\tctx.fillText(\"2d Canvas works, too\", 10, 100);\n\n\t\tlet frame = null;\n\n\t\t(function loop() {\n\n\t\t\tif (!!window.userTriggered) {\n\n\t\t\t\tcanvas.width = 640;\n\t\t\t\tcanvas.height = 320;\n\n\t\t\t\tif (frame !== null) {\n\t\t\t\t\tcancelAnimationFrame(frame);\n\t\t\t\t\tcanvasApp(canvas);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tframe = requestAnimationFrame(loop);\n\n\t\t\t\tconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n\t\t\t\tfor (let p = 0; p < imageData.data.length; p += 4) {\n\t\t\t\t\tconst i = p / 4;\n\t\t\t\t\tconst x = i % canvas.width;\n\t\t\t\t\tconst y = i / canvas.height >>> 0;\n\n\t\t\t\t\tconst t = window.performance.now();\n\n\t\t\t\t\tconst r = 64 + (128 * x / canvas.width) + (64 * Math.sin(t / 1000));\n\t\t\t\t\tconst g = 64 + (128 * y / canvas.height) + (64 * Math.cos(t / 1000));\n\t\t\t\t\tconst b = 128;\n\n\t\t\t\t\timageData.data[p + 0] = r;\n\t\t\t\t\timageData.data[p + 1] = g;\n\t\t\t\t\timageData.data[p + 2] = b;\n\t\t\t\t\timageData.data[p + 3] = 255;\n\t\t\t\t}\n\n\t\t\t\tctx.putImageData(imageData, 0, 0);\n\t\t\t}\n\t\t}());\n\n\t\treturn () => {\n\t\t\tcancelAnimationFrame(frame);\n\t\t};\n\t});\n</script>\n\n<style>\n\tcanvas {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tbackground-color: #666;\n\t\t-webkit-mask: url(\"../images/svelte-logo-mask.svg\") 50% 50% content-box view-box no-repeat;\n\t\tmask: url(\"../images/svelte-logo-mask.svg\") 50% 50% content-box view-box no-repeat;\n\t}\n\t#view {\n\t\ttext-align: center;\n\t}\n</style>\n\n<div id=\"view\">\n\t<!--h3>{@html greeting}</h3-->\n\t<canvas\n\t\t\tid='cv' bind:this={canvas}\n\t\t\twidth={width}\n\t\t\theight={height}\n\t\t\tstyle=\"image-rendering:optimizespeed ! important;\"\n\t></canvas>\n</div>\n",
    "<script>\n    import { onMount } from 'svelte';\n    import * as GL from '@sveltejs/gl';\n    import generateFace from './content/grid-generator';\n    import vert from './shaders/custom/normal-selected-txt-vertex-shader.glsl';\n    import frag from './shaders/custom/normal-selected-txt-fragment-shader.glsl';\n\n    export let title;\n\n    export let color = '#F7C77B';\n\n    let w = 1;\n    let h = 1;\n    let d = 1;\n\n    const light = {};\n\n    // initial view\n    let location = new Float32Array([ 0.25, 1, 2.5 ]);\n    let target = new Float32Array([0, 1, 0]);\n\n    const captureViewDirection = (loc, tgt) => \"\";\n\n    function adjustColor (clr, height = 1) {\n        const r = parseInt('0x' + clr.substr(1, 2), 16),\n                g = parseInt('0x' + clr.substr(3, 2), 16),\n                b = parseInt('0x' + clr.substr(5, 2), 16);\n\n        const hr = Math.floor(r * (height / 0.25)),\n                hb = Math.floor(b * (height / 0.25));\n        return Math.abs((((hr < 255) ? hr : r) << 16) + (g << 8) + ((hb < 255) ? hb : b));\n    }\n\n    let webgl;\n    let textures = [];\n    const ctx = document.createElement(\"canvas\").getContext(\"2d\");\n    ctx.canvas.width = 256;\n    ctx.canvas.height = 256;\n    let process_extra_shader_components = (gl, material, model) => {\n        // console.log(\"Process Extra Shader Components\");\n        const program = material.program;\n\n        if (material.vertName == \"normal-selected-txt-vertex-shader\" && material.fragName == \"normal-selected-txt-fragment-shader\") {\n            // console.log(material.vertName, material.fragName);\n\n            const uvCoordLocation = gl.getAttribLocation(program, \"uv\");\n\n            // gl.disable(gl.CULL_FACE); // for double-sided poly\n\n            gl.enableVertexAttribArray(uvCoordLocation);\n            const textureBuffer = gl.createBuffer();\n            const textureCoords = [\n\n                // front: 0 1 2 3\n                1.0, 1.0,\n                0.0, 1.0,\n                1.0, 0.0,\n                0.0, 0.0,\n\n                // left: 1 4 3 6\n                1.0, 1.0,\n                0.0, 1.0,\n                1.0, 0.0,\n                0.0, 0.0,\n\n                // back: 4 5 6 7\n                1.0, 1.0,\n                0.0, 1.0,\n                1.0, 0.0,\n                0.0, 0.0,\n\n                // right: 5 0 7 2\n                1.0, 1.0,\n                0.0, 1.0,\n                1.0, 0.0,\n                0.0, 0.0,\n\n                // top: 4 1 5 0\n                0.0, 1.0,\n                0.0, 0.0,\n                1.0, 1.0,\n                1.0, 0.0,\n\n                // bottom: 3 6 2 7\n                0.0, 1.0,\n                0.0, 0.0,\n                1.0, 1.0,\n                1.0, 0.0,\n            ];\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);\n            gl.vertexAttribPointer(uvCoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n            // Un-bind buffers\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n            if ((material.vertName == \"normal-selected-txt-vertex-shader\" && material.fragName == \"normal-selected-txt-fragment-shader\")) {\n                for (let t = 0; t < 6; ++t) {\n                    if (!!textures[t]) {\n                        const fragmentTextureLocation = gl.getUniformLocation(program, \"uTexture\" + t);\n                        switch(t) {\n                            case 1: gl.activeTexture(gl.TEXTURE1); break;\n                            case 2: gl.activeTexture(gl.TEXTURE2); break;\n                            case 3: gl.activeTexture(gl.TEXTURE3); break;\n                            case 4: gl.activeTexture(gl.TEXTURE4); break;\n                            case 5: gl.activeTexture(gl.TEXTURE5); break;\n                            default:\n                                gl.activeTexture(gl.TEXTURE0);\n                        }\n                        gl.bindTexture(gl.TEXTURE_2D, textures[t]);\n                        gl.uniform1i(fragmentTextureLocation, t);\n                    }\n                }\n            } else {\n                if (!!textures[0]) {\n                    const fragmentTextureLocation = gl.getUniformLocation(program, \"uTexture0\");\n                    gl.activeTexture(gl.TEXTURE0);\n                    gl.bindTexture(gl.TEXTURE_2D, textures[0]);\n                    gl.uniform1i(fragmentTextureLocation, 0);\n                }\n            }\n\n        } else if (material.vertName == \"texture-vertex-shader\" && material.fragName == \"cubemap-fragment-shader\") {\n            // console.log(material.vertName, material.fragName);\n\n            const fragmentTextureLocation = gl.getUniformLocation(program, \"uTexture\");\n\n            if (!!textures[0]) {\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, textures[0]);\n                gl.uniform1i(fragmentTextureLocation, 0);\n            }\n        }\n\n    };\n\n    onMount(() => {\n        let frame;\n\n        console.log(webgl);\n\n        for (let t = 0; t < 6; ++t) {\n            if (!!textures[t] == false) {\n                // Create a texture and create initial bind\n                textures[t] = webgl.createTexture();\n                webgl.bindTexture(webgl.TEXTURE_2D, textures[t]);\n                // webgl.bindTexture(webgl.TEXTURE_CUBE_MAP, texture);\n            }\n        }\n\n        const faceInfos = [\n            // {target: webgl.TEXTURE_CUBE_MAP_POSITIVE_X, faceColor: '#F00', textColor: '#0FF', text: '+X'},\n            // {target: webgl.TEXTURE_CUBE_MAP_NEGATIVE_X, faceColor: '#FF0', textColor: '#00F', text: '-X'},\n            // {target: webgl.TEXTURE_CUBE_MAP_POSITIVE_Y, faceColor: '#0F0', textColor: '#F0F', text: '+Y'},\n            // {target: webgl.TEXTURE_CUBE_MAP_NEGATIVE_Y, faceColor: '#0FF', textColor: '#F00', text: '-Y'},\n            // {target: webgl.TEXTURE_CUBE_MAP_POSITIVE_Z, faceColor: '#00F', textColor: '#FF0', text: '+Z'},\n            // {target: webgl.TEXTURE_CUBE_MAP_NEGATIVE_Z, faceColor: '#F0F', textColor: '#0F0', text: '-Z'}\n            {target: webgl.TEXTURE_2D, faceColor: '#F00', textColor: '#0FF', text: '+X'},\n            {target: webgl.TEXTURE_2D, faceColor: '#FF0', textColor: '#00F', text: '-X'},\n            {target: webgl.TEXTURE_2D, faceColor: '#0F0', textColor: '#F0F', text: '+Y'},\n            {target: webgl.TEXTURE_2D, faceColor: '#0FF', textColor: '#F00', text: '-Y'},\n            {target: webgl.TEXTURE_2D, faceColor: '#00F', textColor: '#FF0', text: '+Z'},\n            {target: webgl.TEXTURE_2D, faceColor: '#F0F', textColor: '#0F0', text: '-Z'}\n        ];\n\n        faceInfos.forEach((faceInfo, i, a) => {\n            const {target, faceColor, textColor, text} = faceInfo;\n            // Asynchronously load an image\n            const img = new Image();\n            img.crossOrigin = '';\n\n            img.id = '' + (i + 1);\n\n            // Use 2d face generator to generate 6 images\n            // generateFace(ctx, faceColor, textColor, text);\n            generateFace(ctx, faceColor, 16);\n\n            // Upload the canvas to the cubemap face.\n            const level = 0;\n            const internalFormat = webgl.RGBA;\n            const format = webgl.RGBA;\n            const type = webgl.UNSIGNED_BYTE;\n            const width = ctx.canvas.width;\n            const height = ctx.canvas.height;\n            const previewWidth = ctx.canvas.width / 4;\n\n            img.style.margin = 'auto';\n            img.style.position = 'fixed';\n            img.style.top = '0px';\n            img.style.left = i * previewWidth + 'px';\n            img.style.width = previewWidth + 'px';\n            img.addEventListener('load', function () {\n                // Now that the image has loaded make copy it to the texture.\n                console.log(\"Bind to texture\");\n                webgl.bindTexture(webgl.TEXTURE_2D, textures[i]);\n                // webgl.bindTexture(webgl.TEXTURE_CUBE_MAP, texture);\n                webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, true);\n                webgl.texImage2D(target, level, internalFormat, format, type, img);\n                webgl.generateMipmap(webgl.TEXTURE_2D);\n                // if (i >= 5) webgl.generateMipmap(webgl.TEXTURE_CUBE_MAP);\n                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST_MIPMAP_LINEAR); // webgl.LINEAR_MIPMAP_LINEAR);\n                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST_MIPMAP_LINEAR); // webgl.LINEAR_MIPMAP_LINEAR);\n                // webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST_MIPMAP_LINEAR); // webgl.LINEAR_MIPMAP_LINEAR);\n                // document.body.appendChild(img);\n            });\n\n            ctx.canvas.toBlob((blob) => {\n                img.src = URL.createObjectURL(blob);\n            });\n\n            // Setup each face so it's immediately renderable\n            if (!!textures[i]) webgl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);\n        });\n\n        const loop = () => {\n            frame = requestAnimationFrame(loop);\n\n            light.x = 3 * Math.sin(Date.now() * 0.001);\n            light.y = 2.5 + 2 * Math.sin(Date.now() * 0.0004);\n            light.z = 3 * Math.cos(Date.now() * 0.002);\n        };\n\n        loop();\n\n        return () => cancelAnimationFrame(frame);\n    });\n</script>\n\n<style>\n\n    @media screen and (max-width: 480px) {\n        .controls {\n            margin-top: 8px;\n        }\n    }\n\n    .controls label input[type=\"color\"] {\n        clear: both;\n        margin: 100px;\n        margin-top: 2px;\n        margin-bottom: 10px;\n    }\n\n    .keys * {\n        padding: 24px;\n    }\n</style>\n\n<GL.Scene bind:gl={webgl} backgroundOpacity=1.0 process_extra_shader_components={process_extra_shader_components}>\n    <GL.Target id=\"center\" location={[0, h/2, 0]}/>\n\n    <GL.OrbitControls maxPolarAngle={Math.PI / 2} {location}>\n        <GL.PerspectiveCamera bind:location={location} lookAt=\"center\" near={0.01} far={1000}/>\n    </GL.OrbitControls>\n\n    <GL.AmbientLight intensity={0.3}/>\n    <GL.DirectionalLight direction={[-1,-1,-1]} intensity={0.5}/>\n\n    <!-- box -->\n    <GL.Mesh\n            geometry={GL.box({})}\n            location={[0,h/2,0]}\n            rotation={[0,-20,0]}\n            scale={[w,h,d]}\n            vert={vert}\n            frag={frag}\n            uniforms={{ color: adjustColor(color), alpha: 1.0 }}\n            transparent\n    />\n\n    <!-- floor -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[0,-0.01,0]}\n            rotation={[-90,0,0]}\n            scale={10}\n            uniforms={{ color: 0xffffff }}\n    />\n\n    <!-- ceiling -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[0,5.0,0]}\n            rotation={[90,0,0]}\n            scale={10}\n            uniforms={{ color: 0xffffff }}\n    />\n\n    <!-- wall1 -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[0,-0.01,-10.0]}\n            rotation={[0,0,0]}\n            scale={10}\n            uniforms={{ color: 0xffffff }}\n    />\n\n    <!-- wall2 -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[10.0,-0.01,0.0]}\n            rotation={[0,-90,0]}\n            scale={10}\n            uniforms={{ color: 0xffffff }}\n    />\n\n    <!-- wall3 -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[-10.0,-0.01,0.0]}\n            rotation={[0,90,0]}\n            scale={10}\n            uniforms={{ color: 0xffffff }}\n    />\n\n    <!-- moving light -->\n    <GL.Group location={[light.x,light.y,light.z]}>\n        <GL.Mesh\n                geometry={GL.sphere({ turns: 36, bands: 36 })}\n                location={[0,0.2,0]}\n                scale={0.1}\n                uniforms={{ color: 0xffffff, emissive: 0xff0000 }}\n        />\n\n        <GL.PointLight\n                location={[0,0,0]}\n                color={0xff0000}\n                intensity={0.6}\n        />\n    </GL.Group>\n</GL.Scene>\n\n<div class=\"controls\">\n    <label>\n        <input type=\"range\" bind:value={w} min={0.1} max={5} step={0.1} /><br /> width ({w})\n    </label>\n\n    <label>\n        <input type=\"range\" bind:value={h} min={0.1} max={5} step={0.1} /><br /> height ({h})\n    </label>\n\n    <label>\n        <input type=\"range\" bind:value={d} min={0.1} max={5} step={0.1} /><br /> depth ({d})\n    </label>\n</div>\n",
    "<script>\n    import { onMount } from 'svelte';\n    import Emitter from './components/invoice/Emitter.svelte';\n    import Clients from './components/invoice/Clients.svelte';\n    import Work from './components/invoice/Work.svelte';\n\n    export let title;\n\n    let buttonText = 'Create Invoice';\n\n    let getEmitters;\n\n    let emitter;\n\n    let getClients;\n\n    let clients;\n\n    let getWork;\n\n    let workSelection;\n\n    let note = \"\";\n\n    let invoiceResult = null;\n\n    async function handleClick() {\n        buttonText = 'Building ...'\n\n        if (!!workSelection && workSelection.length > 0) {\n            let  client;\n            workSelection.filter(w =>\n                clients.filter(c => {\n                    if (c['org'] === w['org']) {\n                        client = c;\n                        return true;\n                    }\n                }).length > 0\n            );\n\n            if (!!client) {\n\n                const invoiceData = {\n                    emitter: emitter,\n                    client: client,\n                    workEntries: workSelection\n                };\n\n                if (!!note) {\n                    invoiceData['note'] = note;\n                }\n\n                await fetch('/create-invoice', {\n                    // headers: {},\n                    method: 'POST',\n                    body: JSON.stringify(invoiceData)\n                })\n                    .then(res => res.json())\n                    .then(json => (invoiceResult = JSON.stringify(json)) && console.log(\"Response: \", json))\n                    .catch(err => (invoiceResult = err) && console.error(err));\n\n            } else {\n                window.alert(\"Work entries do not match any client!\");\n            }\n\n        } else {\n            window.alert(\"Not work entries have been selected!\");\n        }\n\n        buttonText = 'Create Invoice';\n    }\n\n    onMount(async () => {\n        if (typeof getEmitters === 'function' &&\n            typeof getClients === 'function' &&\n            typeof getWork === 'function'\n        ) {\n            console.log(\"Retrieving work data: \");\n            console.log(await getEmitters('shop/data/emitter.csv'));\n            console.log(await getClients('shop/data/clients.csv'));\n            console.log(await getWork('shop/data/work.csv'));\n        }\n    });\n</script>\n\n<style>\n    .invoice-controls {\n        text-align: center;\n        padding: 1em;\n        margin: 0 auto;\n    }\n\n    h1, h2, h3, h4 {\n        text-transform: uppercase;\n        font-size: 4em;\n        font-weight: 100;\n    }\n\n    .invoice-controls .emitter {\n        display: inline-block;\n        float: left;\n        padding: 10px;\n        max-width: 320px;\n        width: max-content;\n        width: -moz-max-content;\n    }\n\n    .invoice-controls .clients {\n        display: inline-block;\n        padding: 10px;\n        max-width: 320px;\n        width: max-content;\n        width: -moz-max-content;\n    }\n\n\n    .invoice-controls .work {\n        clear: both;\n        padding: 10px;\n        width: max-content;\n        width: -moz-max-content;\n    }\n\n    .invoice-controls button {\n        clear: both;\n    }\n\n</style>\n\n<div class=\"invoice-controls\">\n\n    <h4>{title}</h4>\n\n    <div class=\"emitter\">\n        <Emitter bind:emitter=\"{emitter}\" bind:getEmitters=\"{getEmitters}\" />\n    </div>\n\n    <div class=\"clients\">\n        <Clients bind:clients=\"{clients}\" bind:getClients=\"{getClients}\" />\n    </div>\n\n    <br /><br /><br />\n\n    <div class=\"work\">\n        <Work bind:getWorkEntries=\"{getWork}\" bind:selection=\"{workSelection}\" />\n    </div>\n\n    <input name=\"note\" type=\"text\" value=\"{note}\" />\n\n    {#if (!!workSelection && workSelection.length > 0)}\n        {#each workSelection as selected}\n            <p>{selected.org} - {selected.description}</p>\n        {/each}\n    {/if}\n\n    {#if (invoiceResult != null)}\n        <p>{invoiceResult}</p>\n    {/if}\n\n    <button on:click=\"{handleClick}\">{buttonText}</button>\n\n</div>\n",
    "<script>\n\timport { onMount } from 'svelte';\n\timport * as GL from '@sveltejs/gl';\n\timport Keypad from './components/Keypad.svelte';\n\n\texport let title;\n\n\tlet pin;\n\tlet view;\n\t$: view = pin ? pin.replace(/\\d(?!$)/g, '*') : 'enter your pin';\n\n\tfunction handleSubmit() {\n\t\talert(`submitted ${pin}`);\n\t}\n\n\texport let color = '#ff3e00';\n\tlet w = 1;\n\tlet h = 1;\n\tlet d = 1;\n\n\tconst light = {};\n\n\t// initial view\n\tlet location = new Float32Array([ 0.25, 0.5, 2.5 ]);\n\tlet target = new Float32Array([0, 1, 0]);\n\n\tconst captureViewDirection = (loc, tgt) => \"\";\n\n\tconst from_hex = hex => parseInt(hex.slice(1), 16);\n\n\tonMount(() => {\n\t\tlet frame;\n\n\t\tconst loop = () => {\n\t\t\tframe = requestAnimationFrame(loop);\n\n\t\t\tlight.x = 3 * Math.sin(Date.now() * 0.001);\n\t\t\tlight.y = 2.5 + 2 * Math.sin(Date.now() * 0.0004);\n\t\t\tlight.z = 3 * Math.cos(Date.now() * 0.002);\n\t\t};\n\n\t\tloop();\n\n\t\treturn () => cancelAnimationFrame(frame);\n\t});\n</script>\n\n<style>\n\t.keys {\n\t\ttop: calc(50vh - (100vw / 5.75));\n\t\tright: 0;\n\t\tmargin: 8px;\n\t\tmargin-top: 128px;\n\t\tposition: absolute;\n\t\twidth: 256px;\n\t\theight: 256px;\n\t\tpadding: 24px;\n\t\tbackground-color: transparent;\n\t\tz-index: 2;\n\t}\n\n\t.keys * {\n\t\tpadding: 24px;\n\t}\n</style>\n\n<GL.Scene>\n\t<GL.Target id=\"center\" location={[0, h/2, 0]}/>\n\n\t<GL.OrbitControls maxPolarAngle={Math.PI / 2} {location} {target}>\n\t\t{captureViewDirection(location, target)}\n\t\t<GL.PerspectiveCamera bind:location={location} lookAt=\"center\" near={0.01} far={1000}/>\n\t</GL.OrbitControls>\n\n\t<GL.AmbientLight intensity={0.3}/>\n\t<GL.DirectionalLight direction={[-1,-1,-1]} intensity={0.5}/>\n\n\t<!-- box -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.box({})}\n\t\t\tlocation={[0,h/2,0]}\n\t\t\trotation={[0,-20,0]}\n\t\t\tscale={[w,h,d]}\n\t\t\tuniforms={{ color: from_hex(color) }}\n\t/>\n\n\t<!-- spheres -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\tlocation={[-0.5, 0.4, 1.2]}\n\t\t\tscale={0.4}\n\t\t\tuniforms={{ color: 0x123456, alpha: 0.9 }}\n\t\t\ttransparent\n\t/>\n\n\t<GL.Mesh\n\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\tlocation={[-1.4, 0.6, 0.2]}\n\t\t\tscale={0.6}\n\t\t\tuniforms={{ color: 0x336644, alpha: 1.0 }}\n\t\t\ttransparent\n\t/>\n\n\t<!-- floor -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,-0.01,0]}\n\t\t\trotation={[-90,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- ceiling -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,5.0,0]}\n\t\t\trotation={[90,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall1 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,-0.01,-10.0]}\n\t\t\trotation={[0,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall2 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[10.0,-0.01,0.0]}\n\t\t\trotation={[0,-90,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall3 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[-10.0,-0.01,0.0]}\n\t\t\trotation={[0,90,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- moving light -->\n\t<GL.Group location={[light.x,light.y,light.z]}>\n\t\t<GL.Mesh\n\t\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\t\tlocation={[0,0.2,0]}\n\t\t\t\tscale={0.1}\n\t\t\t\tuniforms={{ color: 0xffffff, emissive: 0xff0000 }}\n\t\t/>\n\n\t\t<GL.PointLight\n\t\t\t\tlocation={[0,0,0]}\n\t\t\t\tcolor={0xff0000}\n\t\t\t\tintensity={0.6}\n\t\t/>\n\t</GL.Group>\n</GL.Scene>\n\n<div class=\"controls\">\n\t<label>\n\t\t<input type=\"color\" style=\"height: 40px\" bind:value={color}>\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={w} min={0.1} max={5} step={0.1}> width ({w})\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={h} min={0.1} max={5} step={0.1}> height ({h})\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={d} min={0.1} max={5} step={0.1}> depth ({d})\n\t</label>\n</div>\n\n<div class=\"controls keys right\">\n\t<h4 style=\"color: {pin ? '#999' : '#fff'}\">{view}</h4>\n\t<Keypad bind:value={pin} on:submit={handleSubmit}/>\n</div>\n",
    "<script>\n    import { onMount } from 'svelte';\n    import * as GL from '@sveltejs/gl';\n    import terrain from './modules/terrain-small';\n    // import terrainFrag from './shaders/default/frag.glsl';\n    // import terrainVert from './shaders/default/vert.glsl';\n    import terrainFrag from './shaders/custom/terrain-frag.glsl';\n    import terrainVert from './shaders/custom/terrain-and-light-vert.glsl';\n\n    export let title;\n\n    export let color = '#F7C77B';\n\n    let use_heightmap = false;\n\n    let w = 1;\n    let h = 1;\n    let d = 1;\n    let rot = 90;\n\n    const light = {\n        color: \"#FFFFFF\"\n    };\n\n    function adjustColor (clr, height = 1) {\n        const r = parseInt('0x' + clr.substr(1, 2), 16),\n                g = parseInt('0x' + clr.substr(3, 2), 16),\n                b = parseInt('0x' + clr.substr(5, 2), 16);\n\n        const hr = Math.floor(r * (height / 0.25)),\n                hb = Math.floor(b * (height / 0.25));\n        return Math.abs((((hr < 255) ? hr : r) << 16) + (g << 8) + ((hb < 255) ? hb : b));\n    }\n\n    function normalizeColor(clr) {\n        const r = parseInt('0x' + clr.substr(1, 2), 16),\n                g = parseInt('0x' + clr.substr(3, 2), 16),\n                b = parseInt('0x' + clr.substr(5, 2), 16);\n\n        return [ r/255, g/255, b/255 ];\n    }\n\n    let webgl;\n    let normalmap;\n    let process_extra_shader_components = (gl, material, model) => {\n        console.log(\"Process Extra Shader Components\");\n        const program = material.program;\n\n        if (material.vertName === \"terrain-vert\") {\n            // console.log(material.vertName);\n\n            const heigthAdjMultLocation = gl.getUniformLocation(program, \"height_adjustment\");\n            gl.uniform1f(heigthAdjMultLocation, (use_heightmap) ? 0.5 : 0.000125); // if using GL.terrain() (which is flat) use larger adjustment => 0.125\n\n            // uniform vec3 light_direction; // normalized direction in eye\n            const lightDirectionLocation = gl.getUniformLocation(program, \"light_direction\");\n            gl.uniform3fv(lightDirectionLocation, new Float32Array([light.x,light.y,light.z]));\n            // uniform vec3 light_ambient_color;\n            const ambientLightLocation = gl.getUniformLocation(program, \"light_ambient_color\");\n            gl.uniform3fv(ambientLightLocation, new Float32Array([...normalizeColor(light.color)]));\n            // uniform vec3 light_diffuse_color;\n            const diffuseLightLocation = gl.getUniformLocation(program, \"light_diffuse_color\");\n            gl.uniform3fv(diffuseLightLocation, new Float32Array([...normalizeColor(light.color)]));\n            // uniform vec3 light_specular_color;\n            const specularLightLocation = gl.getUniformLocation(program, \"light_specular_color\");\n            gl.uniform3fv(specularLightLocation, new Float32Array([...normalizeColor(light.color)]));\n\n            // uniform float material_specular_exponent;\n            const specularExpLocation = gl.getUniformLocation(program, \"material_specular_exponent\");\n            gl.uniform1f(specularExpLocation, 0.99);\n\n        }\n\n    };\n\n    onMount(() => {\n        let frame;\n\n        const map_src = document.getElementById(\"heightmap\").src\n\n        if (map_src.match(/height/) !== null) use_heightmap = true;\n\n        normalmap = new GL.Texture(document.getElementById(\"heightmap\").src, { width: 512, height: 512 });\n\n        light.z = 0.1 * Math.cos(Date.now() * 0.0002);\n\n        const loop = () => {\n            frame = requestAnimationFrame(loop);\n            light.x = 1.5 * Math.sin(Date.now() * 0.0001);\n            light.y = h + h/2 * Math.sin(Math.pow((h - light.x)/2, 2));\n        };\n\n        loop();\n\n        return () => cancelAnimationFrame(frame);\n    });\n</script>\n\n<style>\n    .controls {\n        width: 256px;\n    }\n</style>\n\n<GL.Scene bind:gl={webgl} backgroundOpacity=1.0 process_extra_shader_components={process_extra_shader_components}>\n    <GL.Target id=\"center\" location={[0, h/2 - h, 0]}/>\n\n    <GL.OrbitControls maxPolarAngle={Math.PI / 2} let:location>\n        <GL.PerspectiveCamera {location} lookAt=\"center\" near={0.01} far={1000}/>\n    </GL.OrbitControls>\n\n    <GL.AmbientLight intensity={0.3}/>\n    <GL.DirectionalLight direction={[-1,-1,-1]} intensity={0.5}/>\n\n    <!-- ground -->\n    <GL.Mesh\n            geometry={((use_heightmap) ? GL.terrain() : terrain())}\n            location={[0, -h/2, 0]}\n            rotation={[-rot, 0, 0]}\n            scale={h}\n            frag={terrainFrag}\n            vert={terrainVert}\n            uniforms={{ color: adjustColor(color, h), alpha: 1.0, normalmap: normalmap }}\n    />\n\n    <!-- water -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[0, -h * 63/128, 0]}\n            rotation={[-90, 0, 0]}\n            scale={h}\n            uniforms={{ color: 0x0066ff, alpha: 0.45 }}\n            transparent\n    />\n\n    <!-- moving light -->\n    <GL.Group location={[light.x,light.y,light.z]}>\n        <GL.PointLight\n                location={[0,0,0]}\n                color={adjustColor(color, 1.0)}\n                intensity={0.6}\n        />\n    </GL.Group>\n</GL.Scene>\n\n<div class=\"controls right\">\n    <label>\n        <input type=\"color\" style=\"height: 64px\" bind:value={color}>\n    </label>\n\n    <label>\n        <input type=\"range\" bind:value={h} min={0.75} max={2} step={0.05}><br />\n        size ({h})\n    </label>\n\n    <label>\n        <input type=\"range\" bind:value={rot} min={0} max={180} step={15.0}><br />\n        rotation ({rot})\n    </label>\n</div>\n",
    "<script>\n    import {  createEventDispatcher } from 'svelte';\n\n    export let title;\n    export let color = '#ff3e00';\n\n    export let options = [];\n    export let rangeOptions = [];\n    export let rangeValues = [];\n\n    export let viewLocation, viewTarget;\n\n    let dispatch = createEventDispatcher();\n\n    let formatPlayTime = (time) => \"\" + (new Date(time).toString());\n\n    let mouse_x = 0, mouse_y = 0, mouse_down = false, mouse_disabled = false;\n\n    let navContext;\n\n    let sinceLastMovementEvent = 0;\n\n    let isFullscreen = false;\n\n    let toggleFullscreen = function () {};\n\n    export const init = function () {\n        console.log(\"Initializing Controls...\");\n\n        document.querySelectorAll('.controls h4').forEach(c => {\n            console.log(c);\n\n            const scrollLength = 3 * window.innerHeight / 4;\n            c.addEventListener('click', function (event) {\n                let scrollInterval = 33;\n                let scrollTime = 533;\n                let scrolled = 0\n\n                const startScroll = setInterval(function () {\n                    if (scrolled < scrollLength) {\n                        scroll({top: scrolled, left: 0});\n                    }\n                    scrolled += Math.floor(scrollLength / (scrollTime / scrollInterval));\n                }, scrollInterval);\n\n            });\n\n            c.title = \"Click To See Article\";\n        });\n\n        document.querySelectorAll('canvas').forEach(c => {\n            console.log(c);\n\n            toggleFullscreen = () => {\n                if (!isFullscreen) {\n                    isFullscreen = true;\n                    c.parentElement.className += \" fullscreen\"\n                    for (const control of document.getElementsByClassName(\"controls\")) {\n                        control.className += \" fullscreen\";\n                    }\n                } else {\n                    isFullscreen = false;\n                    c.parentElement.className = c.parentElement.className.replace(\"fullscreen\", '');\n                    for (const control of document.getElementsByClassName(\"controls\")) {\n                        control.className = control.className.replace(\"fullscreen\", '');\n                    }\n                }\n            }\n\n            c.addEventListener('keydown', function (event) {\n                const kbEvent = (event || window['event']); // cross-browser shenanigans\n\n                if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {\n\n                    // console.log(kbEvent);\n\n                    sinceLastMovementEvent = (new Date()).getTime();\n\n                    if (kbEvent['keyCode'] === 32) { // spacebar\n\n                        kbEvent.preventDefault();\n\n                        return true;\n\n                    } else if (kbEvent['keyCode'] === 38 || kbEvent['keyCode'] === 87) { // up || W\n\n                        dispatch('forward');\n\n                        kbEvent.preventDefault();\n\n                        return true;\n\n                    } else if (kbEvent['keyCode'] === 40 || kbEvent['keyCode'] === 83) { // down || S\n\n                        dispatch('backward');\n\n                        kbEvent.preventDefault();\n\n                        return true;\n\n                    } else if (kbEvent['keyCode'] === 37 || kbEvent['keyCode'] === 65) { // left || A\n\n                        dispatch('left');\n\n                        kbEvent.preventDefault();\n\n                        return true;\n\n                    } else if (kbEvent['keyCode'] === 39 || kbEvent['keyCode'] === 68) { // right || D\n\n                        dispatch('right');\n\n                        kbEvent.preventDefault();\n\n                        return true;\n\n                    } else {\n                        console.log('Keyboard Event: ', kbEvent['keyCode']);\n\n                        return false;\n                    }\n                }\n            });\n\n            c.addEventListener('wheel', function (event) {\n                const wheelEvent = (event || window['event']);\n\n                if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {\n\n                    sinceLastMovementEvent = (new Date()).getTime();\n\n                    if (wheelEvent.deltaY < 0) {\n                        dispatch('up');\n                    } else if (wheelEvent.deltaY > 0) {\n                        dispatch('down');\n                    }\n                }\n\n                // wheelEvent.preventDefault();\n            });\n        });\n    };\n</script>\n\n<style>\n    .controls h4 {\n        color: black;\n        cursor: pointer;\n        pointer-events: all;\n    }\n</style>\n\n<div class=\"controls right\">\n\n    <h4>{ title }</h4>\n\n    {#if (options['labels'].length > 0 && options['values'].length > 0)}\n        {#each options['values'] as option, o}\n            <label>\n                <input type=\"checkbox\" bind:checked={option.value} /> {options['labels'][o]}\n            </label><br />\n        {/each}\n    {/if}\n\n    {#if (!!color)}\n        <label>\n            <input type=\"color\" style=\"height: 40px\" bind:value={color}>\n        </label>\n    {/if}\n\n    {#if (rangeOptions['labels'].length > 0 && rangeValues.length > 0)}\n        {#each rangeValues as option, o}\n            <label>\n                <input type=\"range\" bind:value={option} min={rangeOptions['min'][o]} max={rangeOptions['max'][o]} step={rangeOptions['step'][o]} /><br />\n                {rangeOptions['labels'][o]}({option})\n            </label><br />\n        {/each}\n    {/if}\n\n    <label>\n        <button on:click=\"{toggleFullscreen}\">{((isFullscreen) ? 'minimize' : 'maximize')}</button>\n    </label>\n\n</div>\n",
    "<script>\n\timport { createEventDispatcher } from 'svelte';\n\n\texport let value = '';\n\n\tconst dispatch = createEventDispatcher();\n\n\tconst select = num => () => value = `${value}${num}`;\n\tconst clear  = () => value = '';\n\tconst submit = () => dispatch('submit');\n\n\tdocument.addEventListener('keydown', function (event) {\n\t\tconst kbEvent = (event || window['event']); // cross-browser shenanigans\n\n\t\tconsole.log(kbEvent);\n\n\t\tif (kbEvent['keyCode'] === 13) { // Enter\n\n\t\t\tsubmit();\n\n\t\t\tkbEvent.preventDefault();\n\n\t\t} else if (kbEvent['keyCode'] === 8 || kbEvent['keyCode'] === 46) { // Backspace or Delete\n\n\t\t\tclear();\n\n\t\t\tkbEvent.preventDefault();\n\n\t\t} else if (47 < kbEvent['keyCode'] && kbEvent['keyCode'] < 58) { // numbers\n\n\t\t\tvalue = `${value}${kbEvent['key']}`;\n\t\t\tconsole.log(value);\n\n\t\t\tkbEvent.preventDefault();\n\n\t\t} else {\n\t\t\tconsole.log('Keyboard Event: ', kbEvent['keyCode']);\n\t\t}\n\n\t\treturn true;\n\t});\n</script>\n\n<style>\n\t.keypad {\n\t\tdisplay: grid;\n\t\tgrid-template-columns: repeat(3, 5em);\n\t\tgrid-template-rows: repeat(4, 3em);\n\t\tgrid-gap: 0.5em\n\t}\n\n\tbutton {\n\t\tmargin: 0\n\t}\n</style>\n\n<div class=\"keypad\">\n\t<button on:click={select(1)}>1</button>\n\t<button on:click={select(2)}>2</button>\n\t<button on:click={select(3)}>3</button>\n\t<button on:click={select(4)}>4</button>\n\t<button on:click={select(5)}>5</button>\n\t<button on:click={select(6)}>6</button>\n\t<button on:click={select(7)}>7</button>\n\t<button on:click={select(8)}>8</button>\n\t<button on:click={select(9)}>9</button>\n\n\t<button disabled={!value} on:click={clear}>clear</button>\n\t<button on:click={select(0)}>0</button>\n\t<button disabled={!value} on:click={submit}>submit</button>\n</div>\n",
    "<script>\n    import {  createEventDispatcher } from 'svelte';\n\n    export let title;\n\n    export let color = '#F7C77B';\n\n    export let extent = [[-1.0, -1.0], [1.0, 1.0]];\n\n    export let groups = {};\n\n    export let options = [];\n\n    export let rangeOptions = [];\n    export let rangeValues = [];\n\n    export let timeExtent = [];\n\n    export let viewLocation, viewTarget;\n    export let worldPosition = {\n        x: 0.0,\n        y: 0.0,\n        z: 0.0,\n        r: 1.0\n    };\n\n    let dispatch = createEventDispatcher();\n\n    let formatPlayTime = (time) => \"\" + (new Date(time).toString());\n\n    let mouse_x = 0, mouse_y = 0, mouse_down = false, mouse_disabled = false;\n\n    let navContext;\n\n    let positive_forward_vector_x = 0;\n    let positive_forward_vector_z = 0;\n\n    const navWidth = 200, navHeight = 200;\n\n    let map = new Image();\n    map.src = \"images/map.png\";\n    map.style.width = navWidth + \"px\";\n    map.style.height = navWidth + \"px\";\n\n    let terrainWidth = extent[1][0] - extent[0][0],\n        terrainDepth = extent[1][1] - extent [0][1];\n\n    let isFullscreen = false;\n\n    let sinceLastMovementEvent = 0;\n\n    let toggleFullscreen = function () {};\n\n    let renderTerrainNavigationCursor = function (ctx) {\n        const width = ctx.canvas.width;\n        const height = ctx.canvas.height;\n        const focusSize = width / (4 * worldPosition.r); // 256\n\n        ctx.clearRect(0, 0, width, height);\n\n        ctx.strokeRect(\n            (width / 2 - focusSize / 2) + (width * worldPosition.x / terrainWidth),\n            (height / 2 - focusSize / 2) + (height * worldPosition.z / terrainDepth),\n            focusSize,\n            focusSize)\n    };\n\n    let triggerMovement = function (direction) {\n        // Get radius of viewing angle\n        const distance = 0.5 / worldPosition.r;\n        const vx = viewLocation[0] - viewTarget[0];\n        const vz = viewLocation[2] - viewTarget[2];\n        const r = Math.sqrt(Math.pow(vx, 2) + Math.pow(vz, 2));\n\n        // console.log(vx, vz, r, distance);\n\n        positive_forward_vector_x = (vx * (r - distance) / (r)) - vx;\n        positive_forward_vector_z = (vz * (r - distance) / (r)) - vz;\n\n        // console.log(positive_forward_vector_x, positive_forward_vector_z);\n\n        // Adjust worldPosition coords\n        switch (direction) {\n            case \"forward\":\n                worldPosition.x += positive_forward_vector_x;\n                worldPosition.z += positive_forward_vector_z;\n                break;\n            case \"backward\":\n                worldPosition.x -= positive_forward_vector_x;\n                worldPosition.z -= positive_forward_vector_z;\n                break;\n            // // Need better math for lateral movement...\n            // case \"left\":\n            //     if (Math.abs(vx) > Math.abs(vz)) {\n            //         worldPosition.x -= positive_forward_vector_z;\n            //         worldPosition.z -= positive_forward_vector_x;\n            //     } else {\n            //         worldPosition.x += positive_forward_vector_z;\n            //         worldPosition.z += positive_forward_vector_x;\n            //     }\n            //     break;\n            // case \"right\":\n            //     if (Math.abs(vx) > Math.abs(vz)) {\n            //         worldPosition.x += positive_forward_vector_z;\n            //         worldPosition.z += positive_forward_vector_x;\n            //     } else {\n            //         worldPosition.x -= positive_forward_vector_z;\n            //         worldPosition.z -= positive_forward_vector_x;\n            //     }\n            //     break;\n        }\n\n        if (worldPosition.x < -terrainWidth * 0.45) worldPosition.x = -terrainWidth * 0.45;\n        if (terrainWidth * 0.45 < worldPosition.x) worldPosition.x = terrainWidth * 0.45;\n        if (worldPosition.z < -terrainDepth * 0.45) worldPosition.z = -terrainDepth * 0.45;\n        if (terrainDepth * 0.45 < worldPosition.z) worldPosition.z = terrainDepth * 0.45;\n\n        // Pass event to SvelteGL App for view update\n        dispatch(\"move\");\n\n        if (!!navContext === true) {\n            renderTerrainNavigationCursor(navContext)\n        }\n    }\n\n    let tryDateTime = function (value) {\n        let toDate = value;try {\n            if (parseInt(value) > 1577810000000)\n                toDate = new Date(value).toString().match(/(.+) GMT/)[1];\n        } finally {\n            return toDate;\n        }\n    }\n\n    let zoom = function (y) {\n        worldPosition.y = y;\n        worldPosition.r = Math.pow(2, (-y / 4));\n\n        // Pass event to SvelteGL App for view update\n        dispatch(\"move\");\n\n        if (!!navContext === true) {\n            renderTerrainNavigationCursor(navContext)\n        }\n    }\n\n    let zoomY = 0;\n\n    $: zoom(-zoomY);\n\n    let terrainNavigationCursor = function (cursorCanvas, glCanvas) {\n        const ctx = cursorCanvas.getContext('2d');\n        cursorCanvas.width = 1024;\n        cursorCanvas.height = 1024;\n        cursorCanvas.style.width = navWidth + \"px\";\n        cursorCanvas.style.height = navWidth + \"px\";\n\n        ctx.lineWidth = 8;\n        ctx.strokeStyle = '#ff3e00';\n\n        renderTerrainNavigationCursor(ctx);\n\n        let mouse_x = 0, mouse_y = 0, mouse_down = false, mouse_disabled = false;\n\n        const touchHit = function touchHit(event) {\n            // console.log(event.touches);\n            mouseHit(event.touches[0]);\n        };\n\n        const mouseHit = function mouseHit(event) {\n            const scale_correct = 2.0;\n            const current_x = event.clientX - (cursorCanvas.offsetParent.offsetLeft + cursorCanvas.offsetLeft);  // / parseInt(canvas.style.width.substring(-2,3))\n            const current_y = event.clientY - (cursorCanvas.offsetParent.offsetTop + cursorCanvas.offsetTop); // / parseInt(canvas.style.height.substring(-2,3))\n            if (!mouse_disabled) {\n                const delta_x = (mouse_down) ? current_x - mouse_x : 0.0;\n                const delta_y = (mouse_down) ? current_y - mouse_y : 0.0;\n                // if (mouse_down) {\n                //     console.log('mouse movement (', delta_x, ',', delta_y, ')');\n                // }\n                mouse_x = current_x;\n                mouse_y = current_y;\n                if (mouse_down) {\n                    worldPosition.x += scale_correct * (terrainWidth / 2 * delta_x / parseInt(cursorCanvas.style.width.substring(-2,3)));\n                    worldPosition.z += scale_correct * (terrainDepth / 2 * delta_y / parseInt(cursorCanvas.style.height.substring(-2,3)));\n\n                    // Pass event to SvelteGL App for view update\n                    dispatch(\"move\");\n\n                    renderTerrainNavigationCursor(ctx);\n                }\n            }\n        };\n\n        if ('ontouchmove' in document.createElement('div'))  {\n            cursorCanvas.addEventListener('touchstart', function(e){\n                if (!mouse_disabled) {\n                    // console.log('MouseDown');\n                    touchHit(e);\n                    mouse_down = true;\n                }\n                e.preventDefault();\n            });\n            cursorCanvas.addEventListener('touchmove', function(e){\n                if (!mouse_disabled && mouse_down) {\n                    touchHit(e);\n                }\n                e.preventDefault();\n            });\n            cursorCanvas.addEventListener('touchend', function(e){\n                if (!mouse_disabled) {\n                    // console.log('MouseUp');\n                    mouse_down = false;\n                }\n                e.preventDefault();\n            });\n            console.log('touch is present');\n\n        } else {\n            cursorCanvas.addEventListener('mousedown', function(e) {\n                if (!mouse_disabled) {\n                    // console.log('MouseDown');\n                    mouseHit(e);\n                    mouse_down = true;\n                }\n                e.preventDefault();\n            });\n            cursorCanvas.addEventListener('mousemove', mouseHit);\n            cursorCanvas.addEventListener('mouseup', function (e) {\n                if (!mouse_disabled) {\n                    // console.log('MouseUp');\n                    mouse_down = false;\n                }\n                e.preventDefault();\n            });\n        }\n\n        let sinceLastMovementEvent = 0;\n\n        glCanvas.addEventListener('wheel', function (event) {\n            const wheelEvent = (event || window['event']);\n\n            if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {\n\n                sinceLastMovementEvent = (new Date()).getTime();\n\n                if (wheelEvent.deltaY < 0) {\n                    triggerMovement('forward');\n                } else if (wheelEvent.deltaY > 0) {\n                    triggerMovement('backward');\n                }\n            }\n\n            wheelEvent.preventDefault();\n        });\n\n        document.addEventListener('keydown', function (event) {\n            const kbEvent = (event || window['event']); // cross-browser shenanigans\n\n                console.log(kbEvent);\n\n                if (kbEvent['keyCode'] === 32) { // spacebar\n\n                    kbEvent.preventDefault();\n\n                } else if (kbEvent['keyCode'] === 38 || kbEvent['keyCode'] === 87) { // up || W\n\n                    if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {\n                        sinceLastMovementEvent = (new Date()).getTime();\n                        triggerMovement('forward');\n                    }\n\n                    kbEvent.preventDefault();\n\n                } else if (kbEvent['keyCode'] === 40 || kbEvent['keyCode'] === 83) { // down || S\n\n                    if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {\n                        sinceLastMovementEvent = (new Date()).getTime();\n                        triggerMovement('backward');\n                    }\n\n                    kbEvent.preventDefault();\n\n                    return true;\n\n                } else if (kbEvent['keyCode'] === 37 || kbEvent['keyCode'] === 65) { // left || A\n\n                    if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {\n                        sinceLastMovementEvent = (new Date()).getTime();\n                        triggerMovement('left');\n                    }\n\n                    kbEvent.preventDefault();\n\n                } else if (kbEvent['keyCode'] === 39 || kbEvent['keyCode'] === 68) { // right || D\n\n                    if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {\n                        sinceLastMovementEvent = (new Date()).getTime();\n                        triggerMovement('right');\n                    }\n\n                    kbEvent.preventDefault();\n\n                } else if (kbEvent['keyCode'] === 27) { // ESC\n\n                    kbEvent['minimize'] = true;\n\n                    toggleFullscreen(kbEvent); // minimize\n\n                    kbEvent.preventDefault();\n\n                } else {\n                    console.log('Keyboard Event: ', kbEvent['keyCode']);\n                }\n\n                return true;\n        });\n\n        document.getElementById(\"magnification\").addEventListener('keydown', function (event) {\n            const kbEvent = (event || window['event']); // cross-browser shenanigans\n\n            kbEvent.preventDefault();\n\n            return true;\n        });\n\n        return ctx;\n    }\n\n    export const init = function () {\n        console.log(\"Initializing Terrain Navigation Controls...\");\n\n        document.querySelectorAll('main div[role=\"main\"] .container canvas').forEach(c => {\n            console.log(c);\n\n            if (!!navContext !== true) {\n                const mapCursor = document.getElementById(\"terrain-navigation-cursor\");\n                navContext = terrainNavigationCursor(mapCursor, c);\n\n                let intro;\n                let sinceLastMoveBack = (new Date()).getTime();\n\n                const loop = () => {\n\n                    if (zoomY > -2.5) {\n                        zoomY -= 0.15;\n                        zoom(-(zoomY.toFixed(2)));\n                        if (((new Date()).getTime() - sinceLastMoveBack) > 66) {\n                            sinceLastMoveBack = (new Date()).getTime();\n                            triggerMovement('backward');\n                        }\n                        intro = requestAnimationFrame(loop);\n                    } else {\n                        zoomY = -2.5;\n                        zoom(-zoomY);\n                    }\n                };\n\n                setTimeout(loop, 533);\n            }\n\n            toggleFullscreen = (event) => {\n                console.log(event['minimize']);\n\n                if (!!event['minimize'] | !!isFullscreen) {\n                    isFullscreen = false;\n                    c.parentElement.className = c.parentElement.className.replace(\"fullscreen\", '');\n                    for (const control of document.getElementsByClassName(\"controls\")) {\n                        control.className = control.className.replace(\"fullscreen\", '');\n                    }\n\n                } else {\n                    isFullscreen = true;\n                    c.parentElement.className += \" fullscreen\"\n                    for (const control of document.getElementsByClassName(\"controls\")) {\n                        control.className += \" fullscreen\";\n                    }\n                }\n            }\n        });\n    };\n</script>\n\n<style>\n\n    .controls h4 {\n        color: black;\n        cursor: pointer;\n        pointer-events: all;\n    }\n\n    .controls label input[type=\"color\"] {\n        margin: 2px 100px 10px;\n    }\n\n    .controls label input[type=\"checkbox\"] {\n        float: left;\n        margin-left: 32px;\n        margin-right: -48px;\n    }\n\n    .controls label input[type=\"color\"] {\n        clear: both;\n    }\n\n    .controls #terrain-navigation-view img {\n        float: none;\n        margin: 2px;\n        width: 200px;\n        height: 200px;\n    }\n\n    .controls #terrain-navigation-view {\n        padding: 2px;\n    }\n\n    .controls #terrain-navigation-cursor {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        margin-top: 16px;\n        margin-left: 64px;\n        min-width: 20px;\n        min-height: 20px;\n        border: 2px solid;\n    }\n\n    @media screen and (max-width: 480px) {\n        .controls {\n            margin-top: 8px;\n        }\n    }\n\n</style>\n\n<div class=\"controls right\" style=\"top: -5em;\">\n    <!--{#if (!!color)}-->\n    <!--    <label>-->\n    <!--        <input type=\"color\" style=\"height: 40px\" bind:value={color}>-->\n    <!--    </label>-->\n    <!--{/if}-->\n\n    <div id=\"terrain-navigation-view\">\n        <img alt=\"Navigation Controls Map\"\n             src={map.src}\n             width={map.style.width}\n             height={map.style.height} />\n        <canvas id=\"terrain-navigation-cursor\"\n                width=\"{map.width}\"\n                height=\"{map.height}\"\n                style=\"border-color: {color}\"\n        ></canvas>\n    </div>\n\n    <label>\n        <b>-</b><input id=\"magnification\" type=\"range\" bind:value={zoomY} on:input={zoomY} min={-4.0} max={0.5} step={0.1}><b>+</b><br />\n        magnification({zoomY})\n    </label><br />\n\n    {#if (groups.length > 0)}\n        {#each groups as group, i}\n            <label>\n                <input type=\"checkbox\" bind:checked={group} on:click={() => dispatch(\"clickCheckbox\")} /> Group {i + 1}\n            </label><br />\n        {/each}\n    {/if}\n\n    {#if (options['labels'].length > 0 && options['values'].length > 0)}\n        {#each options['values'] as option, o}\n            <label>\n                <input type=\"checkbox\" bind:checked={option} /> {options['labels'][o]}\n            </label><br />\n        {/each}\n    {/if}\n\n    {#if (rangeOptions['labels'].length > 0 && rangeValues.length > 0)}\n        {#each rangeValues as option, o}\n            <label>\n                <input type=\"range\" bind:value={option} min={rangeOptions['min'][o]} max={rangeOptions['max'][o]} step={rangeOptions['step'][o]} /><br />\n                {rangeOptions['labels'][o]}({tryDateTime(option)})\n            </label><br />\n        {/each}\n    {/if}\n\n    <label>\n        <button on:click=\"{toggleFullscreen}\">{((isFullscreen) ? 'minimize' : 'maximize')}</button>\n    </label>\n\n</div>\n",
    "<script>\n    import * as d3 from \"d3\";\n\n    export let clients;\n\n    export const getClients = async (data) => {\n        clients = (await getClientData(data));\n        return clients;\n    };\n\n    async function getClientData (data) {\n        return (await d3.csv(data)).map(d => ({\n            // TODO: validate field values...\n            org: d['org'],\n            company_name: d['company_name'],\n            first_name: d['first_name'],\n            last_name: d['last_name'],\n            street_number: d['street_number'],\n            street_name: d['street_name'],\n            city: d['city'],\n            country: d['country'], // state\n            zip_code: d['zip_code'],\n            phone: d['phone'],\n            mail: d['mail'],\n            website: d['website']\n        }));\n    }\n\n</script>\n\n<style>\n    article {\n        margin-top: 20px;\n        padding: 0;\n        /*border: 2px solid black;*/\n    }\n\n    article:not(:first-of-type) {\n        border-top: none;\n    }\n\n    ul {\n        margin: 0;\n        padding: 0;\n    }\n\n    article * li {\n        display: inline-flex;\n        list-style: none;\n        padding: 2px;\n    }\n\n    ul:hover {\n        background-color: rgba(202, 202, 202, 0.5);\n    }\n\n    ul:hover {\n        color: #000;\n    }\n\n    ul li span.name {\n        font-weight: bolder;\n    }\n\n    ul li span.date-time {\n        font-family: \"Consolas\", \"Fira Code Retina\", \"Source Code Pro\", \"FreeMono\", Monospaced,sans-serif;\n    }\n\n</style>\n\n{#if (!!clients && clients.length > 0)}\n{#each clients as client}\n    <article>\n        <ul class=\"asset\" layout>\n            <li><input class=\"key\" type=\"hidden\" value=\"{client.org}\" /></li>\n            <li flex><span class=\"name\">{client.company_name}</span></li>\n            <li flex><span class=\"first_name\">{client.first_name}</span></li>\n            <li flex><span class=\"last_name\">{client.last_name}</span></li>\n            <li flex=\"50\" layout>\n                <div flex><span class=\"street_number\">{client.street_number}</span></div>&nbsp;\n                <div flex><span class=\"street_number\">{client.street_name}</span></div>\n            </li>\n            <li flex=\"50\" layout>\n                <div flex><span class=\"street_number\">{client.city}</span></div>,&nbsp;\n                <div flex><span class=\"street_number\">{client.country}</span></div>&nbsp;\n                <div flex><span class=\"street_number\">{client.zip_code}</span></div>\n                <!--div flex><span class=\"date-time created_at\">{(new Date(created_at).toDateString())}</span></div-->\n                <!--div flex><span class=\"date-time last_modified\">{(new Date(last_modified).toDateString())}</span></div-->\n            </li>\n            <li flex><span class=\"phone\">{client.phone}</span></li>\n            <li flex><span class=\"mail\">{client.mail}</span></li>\n            <li flex><span class=\"website\">{client.website}</span></li>\n            <!--li flex=\"25\">\n                <div flex><input class=\"action\" type=\"button\" value=\"select\" disabled /></div>\n            </li-->\n        </ul>\n    </article>\n{/each}\n{/if}\n",
    "<script>\n    import * as d3 from \"d3\";\n\n    export let emitter;\n\n    export const getEmitters = async (data) => {\n        emitters = (await getEmitterData(data));\n        emitter = emitters[0];\n        return emitters;\n    };\n\n    let emitters;\n\n    async function getEmitterData (data) {\n        return (await d3.csv(data)).map(d => ({\n            // TODO: validate field values...\n            org: d['org'],\n            name: d['name'],\n            first_name: d['first_name'],\n            last_name: d['last_name'],\n            street_number: d['street_number'],\n            street_name: d['street_name'],\n            city: d['city'],\n            country: d['country'], // state\n            zip_code: d['zip_code'],\n            phone: d['phone'],\n            mail: d['mail'],\n            website: d['website']\n        }));\n    }\n\n</script>\n\n<style>\n    article {\n        margin-top: 20px;\n        padding: 0;\n        /*border: 2px solid black;*/\n    }\n\n    article:not(:first-of-type) {\n        border-top: none;\n    }\n\n    ul {\n        margin: 0;\n        padding: 0;\n    }\n\n    article * li {\n        display: inline-flex;\n        list-style: none;\n        padding: 2px;\n    }\n\n    ul:hover {\n        background-color: rgba(202, 202, 202, 0.5);\n    }\n\n    ul:hover {\n        color: #000;\n    }\n\n    ul li span.name {\n        font-weight: bolder;\n    }\n\n    ul li span.date-time {\n        font-family: \"Consolas\", \"Fira Code Retina\", \"Source Code Pro\", \"FreeMono\", Monospaced,sans-serif;\n    }\n\n</style>\n\n{#if (!!emitters && emitters.length > 0)}\n{#each emitters as emitter}\n    <article>\n        <ul class=\"asset\" layout>\n            <li><input class=\"key\" type=\"hidden\" value=\"{emitter.org}\" /></li>\n            <li flex><span class=\"name\">{emitter.name}</span></li>\n            <li flex><span class=\"first_name\">{emitter.first_name}</span></li>\n            <li flex><span class=\"last_name\">{emitter.last_name}</span></li>\n            <li flex=\"50\" layout>\n                <div flex><span class=\"street_number\">{emitter.street_number}</span></div>&nbsp;\n                <div flex><span class=\"street_number\">{emitter.street_name}</span></div>\n            </li>\n            <li flex=\"50\" layout>\n                <div flex><span class=\"street_number\">{emitter.city}</span></div>,&nbsp;\n                <div flex><span class=\"street_number\">{emitter.country}</span></div>&nbsp;\n                <div flex><span class=\"street_number\">{emitter.zip_code}</span></div>\n                <!--div flex><span class=\"date-time created_at\">{(new Date(created_at).toDateString())}</span></div-->\n                <!--div flex><span class=\"date-time last_modified\">{(new Date(last_modified).toDateString())}</span></div-->\n            </li>\n            <li flex><span class=\"phone\">{emitter.phone}</span></li>\n            <li flex><span class=\"mail\">{emitter.mail}</span></li>\n            <li flex><span class=\"website\">{emitter.website}</span></li>\n            <!--li flex=\"25\">\n                <div flex><input class=\"action\" type=\"button\" value=\"select\" disabled /></div>\n            </li-->\n        </ul>\n    </article>\n{/each}\n{/if}\n",
    "<script>\n    import * as d3 from \"d3\";\n\n    export let selection = [];\n\n    export const getWorkEntries = async (data) => {\n        entries = (await getWorkData(data));\n        return entries;\n    };\n\n    let entries;\n\n    async function getWorkData (data) {\n        return (await d3.csv(data)).map(d => ({\n            // TODO: validate field values...\n            org: d['org'],\n            code: d['code'],\n            description: d['description'],\n            date: d['date'],\n            price: +d['price'], // make number\n            qt: +d['qt'] // make number\n        }));\n    }\n\n</script>\n\n<style>\n    article {\n        margin-top: 20px;\n        padding: 0;\n        /*border: 2px solid black;*/\n        text-align: left;\n    }\n\n    article:not(:first-of-type) {\n        border-top: none;\n    }\n\n    ul {\n        margin: 0;\n        padding: 0;\n    }\n\n    article * li {\n        display: inline-flex;\n        list-style: none;\n        padding: 2px;\n    }\n\n    ul:hover {\n        background-color: rgba(202, 202, 202, 0.5);\n    }\n\n    ul:hover {\n        color: #000;\n    }\n\n    ul li span.name {\n        font-weight: bolder;\n    }\n\n    ul li span.date-time {\n        font-family: \"Consolas\", \"Fira Code Retina\", \"Source Code Pro\", \"FreeMono\", Monospaced,sans-serif;\n    }\n\n</style>\n\n{#if (!!entries && entries.length > 0)}\n{#each entries as entry, idx}\n    <article>\n        <ul class=\"asset\" layout>\n            <li><input class=\"key\" type=\"hidden\" value=\"{entry.code + '-' + idx}\" /></li>\n            <li flex=\"25\">\n                <div flex>\n                    <input class=\"action\"\n                           name=\"{entry.code + '-' + idx}\"\n                           type=\"checkbox\"\n                           value=\"{entry}\"\n                           bind:group=\"{selection}\" />\n                </div>\n            </li>\n            <li flex><span class=\"code\">{entry.code}</span></li>\n            <li flex><span class=\"description\">{entry.description}</span></li>\n            <li flex=\"50\" layout>\n                <div flex><span class=\"date\">{(new Date(entry.date).toDateString().replace(' ', ', '))}</span></div>,&nbsp;\n                <div flex><span class=\"price\">{entry.price}</span></div>&nbsp;\n                <div flex><span class=\"qt\">{entry.qt}</span></div>\n                <!--div flex><span class=\"date-time created_at\">{(new Date(created_at).toDateString())}</span></div-->\n                <!--div flex><span class=\"date-time last_modified\">{(new Date(last_modified).toDateString())}</span></div-->\n            </li>\n        </ul>\n    </article>\n{/each}\n{/if}\n"
  ],
  "names": [],
  "mappings": "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"
}
